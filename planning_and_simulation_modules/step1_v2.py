# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PlanHeatDPMDockWidget
                                 A QGIS plugin
 District Planninng Module
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
          begin                : 2019-02-19
        git sha              : $Format:%H$
        copyright            : (C) 2019 by softeco
        email                : eglantina.metani@softeco.it  ,  daniele.bonventre@softeco.it
 ***************************************************************************/
"""

import os
import os.path


from PyQt5.QtWidgets import *
from PyQt5 import QtCore
from PyQt5.QtGui import *
from PyQt5 import QtGui, QtWidgets, uic
from PyQt5.QtCore import pyqtSignal
from PyQt5.QtWidgets import QTreeWidget, QMessageBox

# Import PyQt5
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QAction, QMenu, QInputDialog, QLineEdit, QListWidgetItem
# Import qgis main libraries
from qgis.core import *
from qgis.gui import *
from qgis.utils import *
from qgis.core import QgsProject, QgsCoordinateTransform
# Import the custom tree widget items
from .building.Building import *
from .building.DPM import *
from .building.TreeItemManager import TreeItemManager
from .technology.Technology import *
from .Network import Network
from .simpleDialog import Form
from .dialogSources import CheckSourceDialog
from .layer_utils import load_file_as_layer, add_layer_to_group, get_only_new_features
from .Tjulia.DistrictSimulator import DistrictSimulator
from .Transport.Transport_electrical_vehicles_demand import Transport_sector
from .save_utility.upload import Upload
from .dhcoptimizerplanheat.dhcoptimizer_planheat import DHCOptimizerPlanheat
from .AdditionalSimulationParameterGUI import AdditionalSimulationParameterGUI

from .utility.PipeList import PipeList
from .utility.data_manager.TechnologiesTransfer import TechnologiesTransfer
from .utility.data_manager.SourceTransfer import SourceTransfer
from .building.CustomContextMenu import CustomContextMenu
from .utility.BuildingCharacterization.BuildingCharacterizationService import BuildingCharacterizationService
from .utility.NetworkCharacterization.NetworkCharacterizationService import NetworkCharacterizationService
from .config.services.SourcesTableDefaultLoader import SourcesTableDefaultLoader

from .dhcoptimizerplanheat.ui import ui_utils



FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'ui', 'step1_v2.ui'))


class PlanHeatDPMDockWidget(QtWidgets.QDockWidget, FORM_CLASS):

    closingPlugin = pyqtSignal()
    step1_closing_signal = pyqtSignal()
    send_networks = pyqtSignal(list, QgsVectorLayer, QgsVectorLayer, TechnologiesTransfer, SourceTransfer)
    send_widget = pyqtSignal(QTreeWidget, QTableWidget, list, list)
    send_treeWidget = pyqtSignal(QTreeWidget)

    street_layer = None
    building_layer = None
    #network_type = None

    def __init__(self, data_transfer=None, parent=None, work_folder=None):
        """Constructor."""
        super(PlanHeatDPMDockWidget, self).__init__(parent)
        # Set up the user interface.py from Designer.
        # After setupUI you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.iface = iface
        self.setupUi(self)

        locale_en_us = QLocale(QLocale.English, QLocale.UnitedStates)
        self.setLocale(locale_en_us)

        self.phases.setCurrentIndex(0)
        self.tabWidget.setCurrentIndex(0)
        self.work_folder = work_folder
        self.data_transfer = data_transfer
        # self.networkSources.setEnabled(False)

        self.simulator = DistrictSimulator()
        self.trasport_sector_calc = Transport_sector()
        #self.booster = Booster_COP()

        self.list_sources_dhw = []
        self.list_sources_heating = []
        self.list_sources_network = []

        self.init_connections()
        self.DHN_network_list = []
        self.DCN_network_list = []
        self.list_input=[]
        self.listWidget_4.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.listNetworkDCN.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.listWidget_4.itemSelectionChanged.connect(lambda: self.update_editing_available("DHN"))
        self.listNetworkDCN.itemSelectionChanged.connect(lambda: self.update_editing_available("DCN"))


        # self.defaultData.clicked.connect(self.load_default_data)

        # self.streetsListWidget.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        # self.setPipeDiameter.clicked.connect(self.DHN_pipes_selected)
        # self.setPipeDiameter_DCN.clicked.connect(self.DCN_pipes_selected)
        # self.streetsListDCN.itemSelectionChanged.connect(self.DCN_pipes_selected)
        # self.streetsListDCN.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        icon = QIcon()
        icon_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "icons",
                                 "save_as.png")
        icon.addPixmap(QPixmap(icon_path), QIcon.Normal, QIcon.Off)
        self.save_existing_network_button.setIcon(icon)
        self.saveLoad.setIcon(icon)

        icon = QIcon()
        icon_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "icons",
                                 "delete.png")
        icon.addPixmap(QPixmap(icon_path), QIcon.Normal, QIcon.Off)
        self.remove_cool.setIcon(icon)
        self.removeDhw.setIcon(icon)
        self.remove_heat.setIcon(icon)
        self.pushButton_4.setIcon(icon)
        self.removeDCN.setIcon(icon)
        self.remove_network.setIcon(icon)

        icon = QIcon()
        icon_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "icons",
                                 "add.png")
        icon.addPixmap(QPixmap(icon_path), QIcon.Normal, QIcon.Off)
        self.addNetwork.setIcon(icon)
        self.add_old_buildings_button.setIcon(icon)
        self.add_old_streets_button.setIcon(icon)
        self.addDCN.setIcon(icon)
        self.add_old_buildings_button_2.setIcon(icon)
        self.add_old_streets_button_2.setIcon(icon)

        icon = QIcon()
        icon_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "icons",
                                 "edit.png")
        icon.addPixmap(QPixmap(icon_path), QIcon.Normal, QIcon.Off)
        self.add_existing_network_button.setIcon(icon)

        icon = QIcon()
        icon_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "icons",
                                 "open_file.png")
        icon.addPixmap(QPixmap(icon_path), QIcon.Normal, QIcon.Off)
        self.defaultData.setIcon(icon)

        icon = QIcon()
        icon_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "icons",
                                 "app.png")
        icon.addPixmap(QPixmap(icon_path), QIcon.Normal, QIcon.Off)
        self.insertNetwork.setIcon(icon)
        self.insertCooling.setIcon(icon)
        self.insertDHW.setIcon(icon)
        self.insertHeating.setIcon(icon)

        icon = QIcon()
        icon_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "icons",
                                 "gunsight.ico")
        icon.addPixmap(QPixmap(icon_path), QIcon.Normal, QIcon.Off)
        self.create_generation_point.setIcon(icon)
        self.create_generation_point_2.setIcon(icon)

        icon = QIcon()
        icon_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "icons",
                                 "connect.png")
        icon.addPixmap(QPixmap(icon_path), QIcon.Normal, QIcon.Off)
        self.connect_generation_point.setIcon(icon)
        self.connect_generation_point_2.setIcon(icon)

        icon = QIcon()
        icon_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "icons",
                                 "clos.png")
        icon.addPixmap(QPixmap(icon_path), QIcon.Normal, QIcon.Off)
        self.closeEditing_2.setIcon(icon)
        #self.close.setIcon(icon)

        self.checkBox_3.hide()
        self.checkBox_4.hide()
        self.label_22.hide()
        self.phases.setTabEnabled(1, False)
        self.phases.setTabEnabled(2, False)
        self.tabWidget.setTabEnabled(0, False)
        self.tabWidget.setTabEnabled(1, False)
        self.tabWidget.setTabEnabled(2, False)

        self.pipes_selected_from_list = True
        self.networks_send = False
        self.heatingTechnology.setItemData(2, 0, Qt.UserRole - 1)
        self.heatingTechnology.setItemData(10, 0, Qt.UserRole - 1)
        self.heatingTechnology.setItemData(17, 0, Qt.UserRole - 1)
        self.dhwTechnology.setItemData(2, 0, Qt.UserRole - 1)
        self.dhwTechnology.setItemData(11, 0, Qt.UserRole - 1)
        self.dhwTechnology.setItemData(18, 0, Qt.UserRole - 1)
        self.networkTechnology.setItemData(0, 0, Qt.UserRole - 1)
        self.networkTechnology.setItemData(8, 0, Qt.UserRole - 1)
        self.networkTechnology.setItemData(12, 0, Qt.UserRole - 1)
        self.networkTechnology.setItemData(28, 0, Qt.UserRole - 1)
        self.networkTechnology.setItemData(36, 0, Qt.UserRole - 1)
        self.dialog = Form()
        self.dialog.InputDemand.connect(self.val_demand)
        # self.type_source_DHW.clicked.connect(self.allocate_sources_DHW)
        # self.type_source_heating.clicked.connect(self.allocate_sources_heating)
        #self.type_source_cooling.clicked.connect(self.allocate_source_cooling)
        # self.networkSources.clicked.connect(self.allocate_source_network)
        # self.btn_dhn.clicked.connect(self.load_folder_dhn)
        # self.btn_dcn.clicked.connect(self.load_folder_dcn)
        self.dmmTreeNetwork.itemClicked.connect(self.network_tree_widget_clicked)

        self.remove_cool.clicked.connect(lambda: self.remove_tech("Cooling"))
        self.remove_heat.clicked.connect(lambda: self.remove_tech("Heating"))
        self.removeDhw.clicked.connect(lambda: self.remove_tech("DHW"))
        self.remove_network.clicked.connect(self.remove_technology)
        self.dialog_source = None
        self.step0_table = None
        self.dialog_source = CheckSourceDialog()
        self.dialog_source.okButton.clicked.connect(self.recived_sources_selected)

        self.heatingTechnology.currentIndexChanged.connect(self.active_source_dialog)
        self.coolingTechnology.currentIndexChanged.connect(self.active_input_cooling)
        self.dhwTechnology.currentIndexChanged.connect(self.active_source_dialogDHW)
        self.networkTechnology.currentIndexChanged.connect(self.active_source_dialogNetwork)

        self.network_service = NetworkCharacterizationService(self)
        self.building_service = BuildingCharacterizationService(self)

        self.tabWidget.currentChanged.connect(self.tab_current_changed)

        self.add_existing_network_button.clicked.connect(self.DHN_optimization)
        self.add_existing_network_button_2.clicked.connect(self.DCN_optimization)

        #self.connect_generation_point.clicked.connect(self.connect_generation_point_DCN)
        #self.connect_generation_point_2.clicked.connect(self.connect_generation_point_DHN)

        self.disable_all_cooling()
        self.disable_all_heating_input()
        self.disable_all_dhw_input()
        self.disable_all_network_tech_input()


        self.add_old_buildings_button.setEnabled(False)
        self.add_old_streets_button.setEnabled(False)
        self.generate_existing_network_button.setEnabled(False)
        self.closeEditing.setEnabled(False)
        self.save_existing_network_button.setEnabled(False)
        self.add_old_buildings_button_2.setEnabled(False)
        self.add_old_streets_button_2.setEnabled(False)
        self.generate_existing_network_button_2.setEnabled(False)
        self.closeEditing_2.setEnabled(False)
        self.save_existing_network_button_2.setEnabled(False)
        self.pipesDiameter.setEnabled(False)
        self.setDiameter.setEnabled(False)
        self.pipesDiameter_2.setEnabled(False)
        self.setDiameter_2.setEnabled(False)
        self.connect_generation_point.setEnabled(False)
        self.connect_generation_point_2.setEnabled(False)
        self.create_generation_point.setEnabled(False)
        self.create_generation_point_2.setEnabled(False)
        self.add_existing_network_button.setEnabled(False)
        self.add_existing_network_button_2.setEnabled(False)

        self.sourceRead = ""
        self.sourceNet = ""
        self.sourceDhw = ""
        self.sourceCool = ""

        self.data_transfer = None
        self.dialog_dock = True
        self.muted = False

        self.coolingTechnology.currentIndexChanged.emit(0)
        self.dhwTechnology.currentIndexChanged.emit(0)
        self.heatingTechnology.currentIndexChanged.emit(0)

        self.pipesDiameter_2.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.pipesDiameter.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)

        self.sourcesTable.setItem(16, 0, QTableWidgetItem())
        self.sourcesTable.setItem(18, 0, QTableWidgetItem())
        self.sourcesTable.setItem(19, 0, QTableWidgetItem())
        self.sourcesTable.setItem(21, 0, QTableWidgetItem())
        self.sourcesTable.setItem(17, 0, QTableWidgetItem())
        self.sourcesTable.setItem(20, 0, QTableWidgetItem())

        self.dhwhCheck.hide()

        self.technology_temp_70 = ["Waste Heat Compression Heat Pump High T"]
        self.technology_temp40_70=["Air Source Compression Heat Pump", "Shallow geothermal compression heat pump",
                                   "Evacuated tube solar collectors",
                                   "Waste heat compression heat pump medium T", "Seasonal waste heat heat pumps",
                                   "Waste heat absorption heat pump",
                                   "Waste heat - heat pump – temperature group 2"]

        self.technology_temp_40 = ["Flat plate solar collectors","Waste heat compression heat pump low T","Waste heat - heat pump – temperature group 1 "]

        self.generate_graph_done = False
        self.connect_generation_point.setEnabled(False)
        self.connect_generation_point_2.setEnabled(False)
        self.create_generation_point.setEnabled(False)
        self.create_generation_point_2.setEnabled(False)

        SourcesTableDefaultLoader.load_default(self.sourcesTable)
        SourcesTableDefaultLoader.hide_default_rows(self.sourcesTable)
        self.defaultData.clicked.connect(lambda: SourcesTableDefaultLoader.load_default(self.sourcesTable))

        self.KPIs_additional_data = {}
        self.dialog_additional_parameters = None
        self.additional_parameters_btn.clicked.connect(self.additional_parameters_btn_handler)

        self.tree_item_manager = TreeItemManager(self.iface, self.dmmTree, self.dmmTreeNetwork,
                                                 [self.DCN_network_list, self.DHN_network_list])
        self.autosave_done = False

    def load_default_data(self):
        pass

    def closeEvent(self, event):
        #self.closingPlugin.emit()
        self.closeStep1()
        event.accept()

    def add_buildings(self, dhcoptimizer):
        dhcoptimizer.dock.add_old_buildings_button.clicked.emit()

    def add_streets_optimizer(self, dhcoptimizer):
        dhcoptimizer.dock.add_old_streets_button.clicked.emit()

    def generate_geography(self, dhcoptimizer, mode):
        self.generate_graph_done = True
        dhcoptimizer.dock.generate_existing_network_button.clicked.emit()
        if mode == "DHN":
            self.create_generation_point.setEnabled(True)
            self.connect_generation_point.setEnabled(True)
        if mode == "DCN":
            self.create_generation_point_2.setEnabled(True)
            self.connect_generation_point_2.setEnabled(True)

    def closeStep1(self):
        self.hide()
        self.step1_closing_signal.emit()
        
    def init_connections(self):
        # add context menu to the tree widget
        self.dmmTree.setContextMenuPolicy(
            QtCore.Qt.CustomContextMenu
        )
        self.dmmTree.customContextMenuRequested.connect(
            self._menu
        )

        self.insertHeating.clicked.connect(
            lambda: self.insert_tech('heating')
        )

        self.insertCooling.clicked.connect(
            lambda: self.insert_tech('cooling')
        )

        self.insertDHW.clicked.connect(
            lambda: self.insert_tech('dhw')
        )

        self.dhwhCheck.stateChanged.connect(
            self.toggle_dhw_input
        )

        self.addNetwork.clicked.connect(self.add_DHN_network)
        self.pushButton_4.clicked.connect(self.remove_DHN_networks)

        self.addDCN.clicked.connect(self.add_DCN_network)
        self.removeDCN.clicked.connect(self.remove_DCN_networks)

        self.save.clicked.connect(self.save_clicked)
        self.save.clicked.connect(self.input_transportSector)
        self.insertNetwork.clicked.connect(self.insert_technology)

        self.PeakDemandDhw.clicked.connect(self.insert_PeakDemandDhw)
        self.PeakDemandCooling.clicked.connect(self.insert_PeakDemandCooling)
        self.PeakDemandHeating.clicked.connect(self.insert_PeakDemandHeating)

    @staticmethod
    def load_layer(qgs_iface, path: str):
        """
        Load the selected layer into the canvas
        :param qgs_iface: main QGis interface.py
        :param path: path to the layer file (*.shp/*.tif)
        :return: the path to the layer and the Qgs layer object
        """
        if os.path.exists(path):
            layer_path, ext = os.path.splitext(path)
            name = layer_path.split('/')[-1]

            # If the layer is a shapefile copy it into memory
            if ext == '.shp':
                # Load the specified layer
                layer = QgsVectorLayer(
                    path,
                    'dmm_output_source',
                    'ogr'
                )
                # Create the memory layer
                layer = qgs_iface.addVectorLayer(path, name, 'ogr')
            else:
                # Raise exception for unsupported files
                raise IOError(f'Unsupported file type: {path}')

            # Raise an exception if loading fails
            if not layer:
                raise IOError('Unable to load layer')
            elif not layer.isValid():
                raise IOError('Invalid Layer')
            else:
                return layer
        else:
            raise FileNotFoundError('Layer does not exist')

    @staticmethod
    def unload_layer(layer: QgsVectorLayer):
        """
        Unload the layer from the interface.py
        :param layer: the layer to be removed
        :return: Success or failure
        """
        try:
            QgsProject.instance().removeMapLayer(layer.id())
            return True
        except Exception as e:
            raise e

    @staticmethod
    def add_layer_fields(layer: QgsVectorLayer, new_fields: list):
        """
        Add fields to a layer
        :param layer: the layer to load the field into
        :param new_fields: the fields to be created as
        :return:
        """
        try:
            layer_dp = layer.dataProvider()
            caps = layer_dp.capabilities()
            if caps & QgsVectorDataProvider.AddAttributes:
                res = layer_dp.addAttributes(new_fields)
                if res:
                    QgsMessageLog.logMessage(
                        'Adding fields!!',
                        level=Qgis.Info
                    )
                else:
                    QgsMessageLog.logMessage(
                        'Impossible to add fields',
                        level=Qgis.Critical
                    )
                layer.updateFields()
        except Exception as e:
            raise e

    @staticmethod
    def delete_layer_fields(layer: QgsVectorLayer, fields: list):
        """
        Delete a list of fields
        :param layer:
        :param fields:
        :return:
        """
        try:
            layer_dp = layer.dataProvider()
            caps = layer_dp.capabilities()
            del_fields = [
                i for i, n in enumerate(
                    layer.getFeatures()) if n.name() in fields
            ]
            if caps & QgsVectorDataProvider.DeleteAttributes:
                res = layer_dp.deleteAttributes(del_fields)
                if res:
                    QgsMessageLog.logMessage(
                        'Deleting fields!!',
                        level=Qgis.Info
                    )
                else:
                    QgsMessageLog.logMessage(
                        'Impossible to delete fields',
                        level=Qgis.Critical
                    )
        except Exception as e:
            raise e

    @staticmethod
    def update_feature_attribute(layer, fid, attributes):
        """
        Modify attributes of a feature.
        :param layer: the layer the feature belongs to
        :param fid: the id of the feature
        :param attributes: the array with the attributes to be changed
        :return:
        """
        layer_dp = layer.dataProvider()
        caps = layer_dp.capabilities()
        if caps & QgsVectorDataProvider.ChangeAttributeValues:
            caps.changeAttributeValues({fid: attributes})

    def load_dpm_layer(self, layer):
        """
        Load the residential layer from dialog
        :return:
        """
        self.dmmTree.clear()
        # path_to_layer = self.layerPath.filePath()
        # if os.path.exists(path_to_layer):
        self.dpm_layer = layer
        #if self.dpm_layer.isValid()

            # The buildings in the baseline scenario
        self.building_layer = layer

            # Connect the layer selection to the tree selection
        self.dpm_layer.selectionChanged.connect(
             self.item_from_feature
        )
            # Load features in the DMM tree
        dmm_tree_root = self.dmmTree.invisibleRootItem()
        for feature in self.dpm_layer.getFeatures():
            building = Building(feature)
            building.layer = self.dpm_layer
            dmm_tree_root.addChild(building)

    def unload_dpm_layer(self):
        """
        Unload the currently loaded residential layer
        :return:
        """
        QgsMessageLog.logMessage(
            f'Removing residential layer {self.dpm_layer.id()}',
            level=Qgis.Warning
        )
        PlanHeatDPM.unload_layer(self.dpm_layer)
        r = self.dmmTree.invisibleRootItem()
        for i in reversed(range(r.childCount())):
            r.removeChild(r.child(i))

    def insert_tech(self, demand: str):
        """
        Insert the given technology into the correct demand item of the
        building tree
        :param demand: the demand item of the building tree
        :return:
        """
        selected = self.dmmTree.selectedItems()
        i = 0
        if demand == 'cooling':
            tech=self.coolingTechnology.currentText()
            source = self.sourceCool
            inclinazione=self.coolingInclinazione.value()
            temperature = self.coolingTemp.value()
            eta_optical = self.coolingEfficiency.value()
            first_order=self.cooling1coeff.value()
            second_order= self.cooling2coeff.value()
            # capacity = self.coolingCapacity.value()
            p_max = self.P_max_cooling.value()
            p_min = self.P_min_cooling.value()
            powerToRatio = self.cb_CHP_cooling.value()
            tech_min = self.coolingTechMin.value()
            ramp_upDown = self.coolingRampUpDown.value()
            fix = self.coolingFixedCost.value()
            fuel = self.coolingFuelCost.value()
            variable = self.coolingVariableCost.value()
            tes_size = self.Tes_size_cooling.value()
            soc_min = self.cooling_socMin.value()
            tes_startEnd = self.cooling_tesStartEnd.value()
            tes_discharge = self.tes_discharge_cooling.value()
            COP_absorption = self.Cop_absorption_cooling.value()
            el_sale = 1
            tes_loss = 1

        elif demand == 'heating':
            #i = 1
            """t = str(
                self.heatingTechnology.currentText()
            )"""

            if self.heatingTechnology.currentIndexChanged:
                tech = self.heatingTechnology.currentText()
                source = self.sourceRead
                #source = self.list_sources_heating[0]
                inclinazione = self.heatingInclinazione.value()
                temperature = self.heatingTemp.value()
                eta_optical = self.heatingEfficiency.value()
                first_order = self.heating1coeff.value()
                second_order = self.heating2coeff.value()
                # capacity = self.heatingCapacity.value()
                p_max = self.P_max_heating.value()
                p_min = self.P_min_heating.value()
                powerToRatio = self.cb_CHP_heating.value()
                tech_min = self.heatingTechMin.value()
                ramp_upDown = self.heatingRampUpDown.value()
                fix = self.heatingFixedCost.value()
                fuel = self.heatingFuelCost.value()
                variable = self.heatingVariableCost.value()
                tes_size = self.Tes_size_heating.value()
                soc_min = self.Soc_min_heating.value()
                tes_startEnd = self.tes_startEnd_heating.value()
                tes_discharge = self.tes_discharge_heating.value()
                COP_absorption = self.COP_heating.value()
                el_sale = self.heatingElsale.value()
                tes_loss = self.heatingTES_loss.value()

            if self.dhwhCheck.isChecked():
                i = 3
            else:
                i = 1

        #if demand == 'dhw':
           # i = 2
        else:
            if self.dhwTechnology.currentIndexChanged:

                tech=self.dhwTechnology.currentText()
                source = self.sourceDhw
                inclinazione = self.dhwInclinazione.value()
                temperature = self.dhwTemp.value()
                eta_optical = self.dhwEfficiency.value()
                first_order = self.dhw1coeff.value()
                second_order = self.dhw2coeff.value()
                # capacity = self.dhwCapacity.value()
                p_max = self.dhwP_max.value()
                p_min = self.dhwP_min.value()
                powerToRatio = self.dhwCb_CHP.value()
                tech_min = self.dhwTechMin.value()
                ramp_upDown = self.dhwRampUpDown.value()
                fix = self.dhwFixedCost.value()
                fuel = self.dhwFuelCost.value()
                variable = self.dhwVariableCost.value()
                tes_size = self.dhwTes_size.value()
                soc_min = self.dhwSoc_min.value()
                tes_startEnd = self.dhwTes_startEnd.value()
                tes_discharge = self.dhwTes_discharge.value()
                COP_absorption = self.dhwCop.value()
                el_sale = self.dhwElsale.value()
                tes_loss = self.DHWTES_loss.value()

                i = 2

                #source = ""
        technology = tech

        for b in selected:
            if b.isHidden():
                continue
            if b.child(i) is not None and not b.child(i).isHidden():
                b.child(i).addChild(
                    Technology(
                        technology,
                        source,
                        inclinazione,
                        temperature,
                        eta_optical,
                        first_order,
                        second_order,
                        p_max,
                        p_min,
                        powerToRatio,
                        tech_min,
                        ramp_upDown,
                        fix,
                        fuel,
                        variable,
                        tes_size,
                        soc_min,
                        tes_startEnd,
                        tes_discharge,
                        COP_absorption,
                        el_sale,
                        tes_loss
                    )
                )

        if tech in self.technology_temp40_70:
            if temperature > 70:
                self.vis_MsgError()

        if tech in self.technology_temp_40:
            if temperature > 40:
                self.vis_MsgError()


    def vis_MsgError(self):
        msgBox = QMessageBox()
        msgBox.setText("WARNING: the input supply temperature does not match the temperature level of the selected technology.")
        msgBox.setStandardButtons(QMessageBox.Cancel | QMessageBox.Ok)
        msgBox.setDefaultButton(QMessageBox.Cancel)
        ret = msgBox.exec()
        if ret == QMessageBox.Cancel:
            return False
        else:
            return True

    def insert_generation(self):
        """
        Insert the generation point into the desired network
        :return:
        """

        network_type = self.networkType.currentText()
        id = self.dhcnID.text()
        source = self.sourceType.currentText()
        inclinazione = self.genInclinazione.value()
        temperature=self.genTemp.value()
        eta_optical = self.genEtaOptical.value()
        first_order = self.genFirstOrder.value()
        second_order= self.genSecondOrder.value()
        # capacity = self.genCap.value()
        p_max = self.genPmax.value()
        p_min = self.genPmin.value()
        powerToRatio = self.genpowerToRatio.value()
        tech_min = self.genTechMin.value()
        ramp_upDown = self.genRampUpDown.value()
        fix = self.genFix.value()
        fuel = self.genFuel.value()
        var = self.genVar.value()
        tes_size = self.genTes_size.value()
        soc_min = self.genSoc_min.value()
        tes_startEnd = self.genTes-startEnd.value()
        tes_discharge = self.gentes_discharge.value()
        COP_absorption = self.genCop.value

        t = self.genTech.currentText().split('-')
        source = t[0].strip()
        technology = t[1].strip()
        if network_type == 'DHN':
            tree = self.dhnTree
            id_list = self.dhn_ids
            self.dhn_gen_count += 1
            cnt = self.dhn_gen_count
            cmb_box = self.dhnSelector
        else:
            tree = self.dcnTree
            id_list = self.dcn_ids
            self.dcn_gen_count += 1
            cnt = self.dcn_gen_count
            cmb_box = self.dcnSelector
        root = tree.invisibleRootItem()
        root.addChild(
            QTreeWidgetItem(
                [
                    id,
                    technology,
                    source,
                    str(inclinazione),
                    str(temperature),
                    str(eta_optical),
                    str(first_order),
                    str(second_order),
                    str(p_max),
                    str(p_min),
                    str(powerToRatio),
                    str(tech_min),
                    str(ramp_upDown),
                    str(fix),
                    str(var),
                    str(fuel),
                    str(tes_size),
                    str(soc_min),
                    str(tes_startEnd),
                    str(tes_discharge),
                    str(COP_absorption)
                ],
                type=QTreeWidgetItem.Type
            )
        )
        if id not in id_list:
            id_list.append(id)
            cmb_box.addItem(id)

    def item_from_feature(self, selected, deselected, clear_select):
        """
        Select a building in the tree. This is a pyqtSlot catching the
        selectionChanged signal
        :return:
        """
        buildings = self.dmmTree.invisibleRootItem()
        if clear_select:
            for i in selected:
                buildings.child(i).setSelected(True)
            for j in deselected:
                buildings.child(j).setSelected(False)

    def connect_to_dcn(self):
        """
        Connect selected buildings to the DCN.
        :return:
        """
        selected = self.dmmTree.selectedItems()
        dcn = self.dcnSelector.currentText()
        for b in selected:
            if isinstance(b, Building):
                b.toggle_dcn(dcn)


    def _menu(self, point):
        """
        Open the context menu for the trees of the widget
        :return:
        """
        print("Step1._menu point:", type(point), point)
        selected = self.dmmTree.itemAt(point)
        print("Step1._menu point:", type(selected), selected)
        menu = QMenu()
        if isinstance(selected, Technology):
            remove = QAction(
                '&Remove Techonolgy',
                self.dmmTree,
            )
            remove.triggered.connect(selected.remove_technology)
            menu.addAction(remove)
        elif isinstance(selected, Building):
            if selected.dcn:
                disconnect_from_dcn = QAction(
                    '&Disconnect from DCN',
                    self.dmmTree
                )
                disconnect_from_dcn.triggered.connect(selected.toggle_dcn)
                menu.addAction(disconnect_from_dcn)
            if selected.dhn:
                disconnect_from_dhn = QAction(
                    '&Disconnect from DHN'
                )
                disconnect_from_dhn.triggered.connect(selected.toggle_dhn)
                menu.addAction(disconnect_from_dhn)
        menu.exec(self.dmmTree.viewport().mapToGlobal(point))

    def toggle_cooling_input(self, state):
        """
        Activate/Deactivate cooling input
        :return:
        """
        if state > 0:
            self.cooling.setEnabled(False)
            self.dcnSelector.setEnabled(True)
            self.connectDCN.setEnabled(True)
        else:
            self.cooling.setEnabled(True)
            self.dcnSelector.setEnabled(False)
            self.connectDCN.setEnabled(False)

    def toggle_heating_input(self, state):
        """
        Activate/Deactivate heating input
        :param state: state of the checkbox
        :return:
        """
        if state > 0:
            self.heating.setEnabled(False)
            self.dhw.setEnabled(False)
            self.dhnSelector.setEnabled(True)
            self.connectDHN.setEnabled(True)
        else:
            self.heating.setEnabled(True)
            self.dhw.setEnabled(True)
            self.dhnSelector.setEnabled(False)
            self.connectDHN.setEnabled(False)

    def toggle_dhw_input(self, state):
        """
        Activate/Deactivate the DHW input
        :param state: state of the checkbox
        :return:
        """
        if state > 0:
            self.dhw.setEnabled(False)
        else:
            self.dhw.setEnabled(True)

    def set_street_layer(self, layer, data_transfer):
        self.street_layer = layer
        #print('!!!', layer.fields().names())
        self.data_transfer = data_transfer
        # self.street_layer.selectionChanged.connect(self.add_streets_to_networks)

    def set_building_layer(self, layer):
        self.building_layer = layer
        # self.building_layer.selectionChanged.connect(self.add_buildings_to_networks)

    def upload_DHN_network(self):

        folder = self.folder_DHN.text()
        if not os.path.exists(folder):
            QMessageBox.warning(None, "Warning", "Folder " + folder + " does not exist")
            return
        # Counting number of files to be open in the selected folder
        file_counter = 0
        for root, dirs, files in os.walk(folder):
            for file in files:
                if  file.endswith('.shp'):
                    file_counter += 1
        if file_counter == 0:
            QMessageBox.information(None, "Warning",
                                    "Folder " + folder + " .shp files. There's nothing to load, here!")
            return
        for root, dirs, files in os.walk(folder):
            for filename in files:
                if filename[-4:] == ".shp":

                    file_path = folder + "\\" + filename
                    if not QgsProject.instance().mapLayersByName(filename):
                        load_file_as_layer(file_path, filename, 'netwok caricata', min_val=None,
                                           max_val=None, mean_val=None, value_color=None, area=None)
                    else:
                        print("File " + file_path + "seems to be already loaded! Skipping file...")

        upload = Upload()
        upload.upload_file_json()

    def upload_DCN_network(self):
        folder = self.folder_DCN.text()
        if not os.path.exists(folder):
            QMessageBox.warning(None, "Warning", "Folder " + folder + " does not exist")
            return
        file_counter = 0
        for root, dirs, files in os.walk(folder):
            for file in files:
                if file.endswith('.shp'):
                    file_counter += 1
        if file_counter == 0:
            QMessageBox.information(None, "Warning",
                                    "Folder " + folder + " .shp files. There's nothing to load, here!")
            return
        for root, dirs, files in os.walk(folder):
            for filename in files:
                if filename[-4:] == ".shp":
                    file_path = folder + "\\" + filename
                    if not QgsProject.instance().mapLayersByName(filename):
                        load_file_as_layer(file_path, filename, 'netwok caricata', min_val=None,
                                           max_val=None, mean_val=None, value_color=None, area=None)
                    else:
                        print("File " + file_path + "seems to be already loaded! Skipping file...")


    def add_network(self, n_type):
        space = "                                       "
        text, ok_pressed = QInputDialog.getText(self, "Create new network", "Type the {0} name:".format(n_type) + space, QLineEdit.Normal, "")
        if ok_pressed and text != '':
            flag = True
            while flag:
                text2, ok_pressed = QInputDialog.getText(self, "Additional information",
                                                        "Please enter the network efficiency \n(usually between 0.01 and 1.00):",
                                                        QLineEdit.Normal, "")
                try:
                    if ok_pressed:
                        efficiency = float(text2)
                        flag = False
                        if efficiency == 0.0:
                            flag = True
                    else:
                        efficiency = 1.0
                        flag = False
                except ValueError:
                    flag = True
            n = Network(text, n_type)
            n.efficiency = efficiency
            n.scenario_type = "baseline"

            group_name = n.n_type + " (" + n.scenario_type + "): " + text + " - ID:" + n.get_ID()

            if n.n_type == "DHN":
                self.DHN_network_list.append(n)
                #self.DHN_network_list[-1].buildings_layer = self.building_layer
                self.refresh_DHN_network()
            if n.n_type == "DCN":
                self.DCN_network_list.append(n)
                #self.DCN_network_list[-1].buildings_layer = self.building_layer
                self.refresh_DCN_network()

            root = QgsProject.instance().layerTreeRoot()
            group = root.findGroup(group_name)
            if group is None:
                root.insertGroup(0, group_name)

    def add_DHN_network(self):
        self.add_network("DHN")

    def add_DCN_network(self):
        self.add_network("DCN")

    def remove_DHN_networks(self):
        network_to_be_removed = []
        for item in self.listWidget_4.selectedItems():
            network_to_be_removed.append(self.listWidget_4.row(item))
        network_to_be_removed.sort()
        for i in range(len(network_to_be_removed)-1, -1, -1):
            self.DHN_network_list[network_to_be_removed[i]].remove_group()            # try:
            del self.DHN_network_list[network_to_be_removed[i]]
        self.refresh_DHN_network()
        self.tree_item_manager.update_buildings_visualizzation()

    def remove_DCN_networks(self):
        network_to_be_removed = []
        for item in self.listNetworkDCN.selectedItems():
            network_to_be_removed.append(self.listNetworkDCN.row(item))
        network_to_be_removed.sort()
        for i in range(len(network_to_be_removed)-1, -1, -1):
            self.DCN_network_list[network_to_be_removed[i]].remove_group()
            del self.DCN_network_list[network_to_be_removed[i]]
        self.refresh_DCN_network()
        self.tree_item_manager.update_buildings_visualizzation()

    def refresh_DHN_network(self):
        self.listWidget_4.clear()
        self.listWidget_4.addItems(n.name for n in self.DHN_network_list)

        # refresh also the dmmtreenetwork
        networks_to_keep = [n.name for n in self.DHN_network_list]
        j = 0
        for i in range(self.dmmTreeNetwork.topLevelItemCount()):
            top_level_item = self.dmmTreeNetwork.topLevelItem(j)
            network_name = top_level_item.text(0).split(" - ")[-1]
            if not network_name not in networks_to_keep:
                self.dmmTreeNetwork.takeTopLevelItem(j)
                self.dmmTreeNetwork.clear()
            else:
                j += 1

    def refresh_DCN_network(self):
        self.listNetworkDCN.clear()
        self.listNetworkDCN.addItems(n.name for n in self.DCN_network_list)

    def add_buildings_to_DHN_networks(self):
        self.add_buildings_to_networks("DHN")
        return

    def add_buildings_to_DCN_networks(self):
        self.add_buildings_to_networks("DCN")
        return

    def add_buildings_to_networks(self, n_type):
        if n_type == "DHN":
            n_list = self.DHN_network_list
            widget = self.listWidget_4
        else:
            if n_type == "DCN":
                n_list = self.DCN_network_list
                widget = self.listNetworkDCN
            else:

                return
        if self.building_layer is None:
            return
        try:
            if not self.building_layer.isValid():
                return
        except:
            return
        for item in widget.selectedItems():
            network_index = widget.row(item)
            n_list[network_index].buildings_layer.startEditing()
            pr = n_list[network_index].buildings_layer.dataProvider()
            pr.addFeatures(get_only_new_features(self.building_layer,
                                                 n_list[network_index].buildings_layer,
                                                 'BuildingID'))
            n_list[network_index].buildings_layer.commitChanges()
        if n_type == "DCN":
            self.refresh_DCN_network_buildings()
        if n_type == "DHN":
            self.refresh_DHN_network_buildings()

    def remove_buildings_from_DHN_networks(self):
        if self.building_layer is None:
            return
        if not self.building_layer.isValid():
            return
        for item in self.listWidget_4.selectedItems():
            network_index = self.listWidget_4.row(item)
            self.DHN_network_list[network_index].buildings_layer.startEditing()
            for building in self.building_layer.selectedFeatures():
                # self.DHN_network_list[network_index].remove_building(building.attribute("BuildingID"))
                for f in self.DHN_network_list[network_index].buildings_layer.getFeatures():
                    if f.attribute("BuildingID") == building.attribute("BuildingID"):
                        self.DHN_network_list[network_index].buildings_layer.deleteFeature(f.id())
            self.DHN_network_list[network_index].buildings_layer.commitChanges()
        self.refresh_DHN_network_buildings()

    def remove_buildings_from_DCN_networks(self):
        if self.building_layer is None:
            return
        if not self.building_layer.isValid():
            return
        for item in self.listNetworkDCN.selectedItems():
            network_index = self.listNetworkDCN.row(item)
            self.DCN_network_list[network_index].buildings_layer.startEditing()
            for building in self.building_layer.selectedFeatures():
                # self.DCN_network_list[network_index].remove_building(building.attribute("BuildingID"))
                for f in self.DCN_network_list[network_index].buildings_layer.getFeatures():
                    if f.attribute("BuildingID") == building.attribute("BuildingID"):
                        self.DCN_network_list[network_index].buildings_layer.deleteFeature(f.id())
            self.DCN_network_list[network_index].buildings_layer.commitChanges()
        self.refresh_DCN_network_buildings()

    def add_streets(self, widget, n_type):
        for item in widget.selectedItems():
            network_index = widget.row(item)
            if n_type == "DHN":
                layer = self.DHN_network_list[network_index].streets_layer
                self.DHN_network_list[network_index].street_quality_status = False
            if n_type == "DCN":
                layer = self.DCN_network_list[network_index].streets_layer
                self.DCN_network_list[network_index].street_quality_status = False
            layer.startEditing()
            pr = layer.dataProvider()
            new_features = get_only_new_features(self.street_layer, layer, 'osmid')
            pr.addFeatures(new_features)
            layer.commitChanges()
            if n_type == "DHN":
                self.DHN_network_list[network_index].update_street_backup(new_features, "add")
            if n_type == "DCN":
                self.DCN_network_list[network_index].update_street_backup(new_features, "add")

    def add_streets_to_networks(self):
        if self.street_layer is None:
            return
        if not self.street_layer.isValid():
            return
        widget = self.listWidget_4
        self.add_streets(widget, "DHN")
        self.refresh_DHN_network_streets()


    def add_streets_to_DCN_networks(self):
        if self.street_layer is None:
            return
        if not self.street_layer.isValid():
            return
        widget = self.listNetworkDCN
        self.add_streets(widget, "DCN")
        self.refresh_DCN_network_streets()


    def remove_streets_from_DHN_networks(self):
        self.remove_streets_from_networks("DHN")
        self.refresh_DHN_network()

    def remove_streets_from_DCN_networks(self):
        self.remove_streets_from_networks("DCN")
        self.refresh_DCN_network()

    def remove_streets_from_networks(self, n_type):
        pipes_widget = None
        if n_type == "DHN":
            n_list = self.DHN_network_list
            pipes_widget = self.streetsListWidget
        if n_type == "DCN":
            n_list = self.DCN_network_list
            pipes_widget = self.streetsListDCN
        if pipes_widget is None:
            return
        for n in n_list:
            n.streets_layer.startEditing()

            for pipe in pipes_widget.selectedItems():
                row = pipe.text().split('|')
                try:
                    pipe_id = int(row[0][9:-1])
                except:
                    continue
                try:
                    network_id = str(pipe.data(Qt.UserRole))
                except:
                    continue

                if n.get_ID() == network_id:
                    expr = QgsExpression("\"ID\"=" + str(pipe_id))
                    ids = [ft.id() for ft in n.streets_layer.getFeatures(QgsFeatureRequest(expr))]
                    n.streets_layer.deleteFeature(ids[0])

                    edge_to_remove = []
                    for e in n.graph.edges(data=True):
                        if e[2]['feature_ID'] == pipe_id:
                            edge_to_remove.append([e[0], e[1]])
                    for edge in edge_to_remove:
                        n.graph.remove_edge(edge[0], edge[1])

            n.streets_layer.commitChanges()

    def refresh_DHN_network_buildings(self):
        self.buildingListWidget.clear()
        buildings_to_display = []
        #if self.building_layer is not None:
        #    self.make_feature_transparent(self.building_layer)
        for item in self.listWidget_4.selectedItems():
            network_index = self.listWidget_4.row(item)
            for building in self.DHN_network_list[network_index].get_building_list():
                buildings_to_display.append(str(building) + " | " + self.DHN_network_list[network_index].name)
        self.buildingListWidget.addItems(buildings_to_display)

    def solar_thermalrefresh_DHN_network_streets(self):
        self.streetsListWidget.clear()
        check = True
        loop = False
        for item in self.listWidget_4.selectedItems():
            loop = True
            network_index = self.listWidget_4.row(item)
            for street in self.DHN_network_list[network_index].get_street_list():
                q = QListWidgetItem()
                q.setData(Qt.UserRole, QVariant(self.DHN_network_list[network_index].get_ID()))
                q.setText(str(street))
                self.streetsListWidget.addItem(q)
            check = check and self.DHN_network_list[network_index].street_quality_status
        if check and loop:
            self.setPipeDiameter.setEnabled(True)
        else:
            self.setPipeDiameter.setEnabled(False)

    def refresh_DCN_network_buildings(self):
        self.buildingListDCN.clear()
        buildings_to_display = []
        for item in self.listNetworkDCN.selectedItems():
            network_index = self.listNetworkDCN.row(item)
            for building in self.DCN_network_list[network_index].get_building_list():
                buildings_to_display.append(str(building) + " - " + self.DCN_network_list[network_index].get_ID())
        self.buildingListDCN.addItems(buildings_to_display)

    def refresh_DCN_network_streets(self):
        self.streetsListDCN.clear()
        check = True
        loop = False
        for item in self.listNetworkDCN.selectedItems():
            network_index = self.listNetworkDCN.row(item)
            for street in self.DCN_network_list[network_index].get_street_list():
                q = QListWidgetItem()
                q.setData(Qt.UserRole, QVariant(self.DCN_network_list[network_index].get_ID()))
                q.setText(str(street))
                self.streetsListWidget.addItem(q)
            check = check and self.DCN_network_list[network_index].street_quality_status
        if check and loop:
            self.setPipeDiameter_DCN.setEnabled(True)
        else:
            self.setPipeDiameter_DCN.setEnabled(False)

    def district_solution_checked(self, state):
        if not state:
            self.checkBox_3.hide()
            self.checkBox_4.hide()
            self.label_22.hide()
        else:
            self.checkBox_3.show()
            self.checkBox_4.show()
            self.label_22.show()

    def DHN_checked(self, state_DHN, state_DCN):
        if state_DHN or state_DCN:
            self.phases.setTabEnabled(1, True)
        else:
            self.phases.setTabEnabled(1, False)
        if not state_DHN:
            self.tabWidget.setTabEnabled(0, False)
            self.tabWidget.setTabEnabled(2, False)
        else:
            self.tabWidget.setTabEnabled(0, True)
            self.tabWidget.setTabEnabled(2, True)

    def DCN_checked(self, state_DHN, state_DCN):
        if state_DHN or state_DCN:
            self.phases.setTabEnabled(1, True)
        else:
            self.phases.setTabEnabled(1, False)
        if not state_DCN:
            self.tabWidget.setTabEnabled(1, False)
            self.tabWidget.setTabEnabled(2, False)
        else:
            self.tabWidget.setTabEnabled(1, True)
            self.tabWidget.setTabEnabled(2, True)

    def Building_checked(self,state):
        if not state:
            self.phases.setTabEnabled(2, False)
        else:
            self.phases.setTabEnabled(2, True)

    def insert_technology(self):

        # if self.networkTechnology.currentIndexChanged:

        technology = self.networkTechnology.currentText()
        source = self.sourceNet
        area = self.networkarea.value()
        temperature = self.networkTemp.value()
        efficiency = self.networkEta.value()
        first_order = self.network1coeff.value()
        second_order = self.network2coeff.value()
        # capacity = self.networkCapacity.value()
        p_max = self.networkP_max.value()
        p_min = self.networkP_min.value()
        powerToRatio = self.networkcb_CHP.value()
        tech_min = self.networkTechMin.value()
        ramp_upDown = self.networkRampUpDown.value()
        variable = self.networkVariableCost.value()
        fix = self.networkFixedCost.value()
        fuel = self.networkFuelCost.value()
        tes_size = self.networkTes_size.value()
        soc_min = self.networkSocMin.value()
        tes_startEnd = self.networkTesStartEnd.value()
        tes_discharge = self.networkTes_discharge.value()
        COP_absorption = self.networkCop_absorption.value()
        el_sale = self.network_el_sale.value()
        tes_loss = self.networkTES_loss.value()

        child = [str(" "),
                 str(technology),
                 str(source),
                 str(area),
                 str(temperature),
                 str(efficiency),
                 str(first_order),
                 str(second_order),
                 str(p_max),
                 str(p_min),
                 str(powerToRatio),
                 str(tech_min),
                 str(ramp_upDown),
                 str(fix),
                 str(variable),
                 str(fuel),
                 str(tes_size),
                 str(soc_min),
                 str(tes_startEnd),
                 str(tes_discharge),
                 str(COP_absorption),
                 str(el_sale),
                 str(tes_loss)]
        new_child = QTreeWidgetItem(child)

        new_child.setData(2, Qt.UserRole, "old_tech")

        parent = self.dmmTreeNetwork.currentItem()
        if parent is None:
            return
        if parent.parent() is not None:
            return
        if parent is None:
             self.dmmTreeNetwork.invisibleRootItem()
        else:
            parent.addChild(new_child)

        if technology in self.technology_temp_70:
            if temperature < 70:
                self.vis_MsgError()


        if technology in self.technology_temp40_70:
            if temperature < 40:
                self.vis_MsgError()

        if technology in self.technology_temp_40:
            if temperature > 40:
                self.vis_MsgError()

    def active_input_cooling(self, p):
        self.disable_all_cooling()
        techn = str(self.coolingTechnology.currentText())

        if techn == self.simulator.technology_for_cooling[0] or techn == self.simulator.technology_for_cooling[1]:
            if techn == self.simulator.technology_for_cooling[0]:
                self.sourceCool = self.simulator.sources_for_technology[0]
            if techn == self.simulator.technology_for_cooling[1]:
                self.sourceCool = self.simulator.sources_for_technology[8]
            self.disable_all_cooling()
            self.coolingTemp.setEnabled(True)
            self.coolingTemp.setEnabled(True)
            self.P_max_cooling.setEnabled(True)
            self.coolingTechMin.setEnabled(True)
            self.coolingRampUpDown.setEnabled(True)
            self.coolingVariableCost.setEnabled(True)
            self.coolingFixedCost.setEnabled(True)
            self.coolingFuelCost.setEnabled(True)

        if techn == self.simulator.technology_for_cooling[2] or techn == self.simulator.technology_for_cooling[3]:
            if techn == self.simulator.technology_for_cooling[2]:
                self.sourceCool = self.simulator.sources_for_technology[9]
            if techn == self.simulator.technology_for_cooling[3]:
                self.sourceCool = self.simulator.sources_for_technology[8]
            self.disable_all_cooling()
            self.coolingTechMin.setEnabled(True)
            self.coolingRampUpDown.setEnabled(True)
            self.coolingVariableCost.setEnabled(True)
            self.coolingFixedCost.setEnabled(True)
            self.Cop_absorption_cooling.setEnabled(True)
            self.P_max_cooling.setEnabled(True)
            self.coolingFuelCost.setEnabled(True)


    def active_source_dialog(self, gf):
        self.disable_all_heating_input()
        self.sourceRead = ' '
        t = str(self.heatingTechnology.currentText())

        key_list = self.simulator.individual_H_C_dict_var.keys()

        for key in key_list:
                z = self.simulator.individual_H_C_dict_var[key]
                # first category HOB
                if t in z:
                    if key == list(key_list)[0]: #heat_only_boiler
                        self.heatingEfficiency.setEnabled(True)
                        # self.heatingCapacity.lineEdit().setEnabled(True)
                        self.P_max_heating.setEnabled(True)
                        self.heatingTechMin.setEnabled(True)
                        self.heatingRampUpDown.setEnabled(True)
                        self.heatingFixedCost.setEnabled(True)
                        self.heatingFuelCost.setEnabled(True)
                        self.heatingVariableCost.setEnabled(True)

                        if t == z[0]:  #Gas Boiler
                            self.sourceRead = self.simulator.sources_for_technology[9] # 'Natural gas'
                        if t == z[2]: #"Oil Boiler"
                            self.sourceRead = self.simulator.sources_for_technology[10] # 'Heating Oil'
                        if t == z[1]: #"Biomass Boiler"
                            self.sourceRead = self.simulator.sources_for_technology[1] # 'Biomass foresty'

                    if key == list(key_list)[1]: #electrical_heater
                        # self.heatingCapacity.lineEdit().setEnabled(True)
                        self.P_max_heating.setEnabled(True)
                        self.heatingTechMin.setEnabled(True)
                        self.heatingEfficiency.setEnabled(True)
                        self.heatingVariableCost.setEnabled(True)
                        self.heatingFuelCost.setEnabled(True)
                        self.heatingFixedCost.setEnabled(True)
                        self.sourceRead = self.simulator.sources_for_technology[11] # 'Electricity'

                    if key == list(key_list)[2]: #heat_pump
                        self.P_max_heating.setEnabled(True)
                        self.heatingTechMin.setEnabled(True)
                        self.heatingRampUpDown.setEnabled(True)
                        self.heatingVariableCost.setEnabled(True)
                        self.heatingFixedCost.setEnabled(True)
                        self.heatingTemp.setEnabled(True)
                        self.heatingFuelCost.setEnabled(True)
                        if t == z[0]:
                            self.sourceRead = self.simulator.sources_for_technology[5]
                        if t == z[1]:
                            self.sourceRead = self.simulator.sources_for_technology[12]
                        if t == z[2]:
                            self.sourceRead = self.simulator.ask_for_sources(t, serv="heating")

                    if key == list(key_list)[3]: #cogeneration
                        self.P_max_heating.setEnabled(True)
                        self.heatingTechMin.setEnabled(True)
                        self.heatingEfficiency.setEnabled(True)
                        self.cb_CHP_heating.setEnabled(True)
                        self.heatingRampUpDown.setEnabled(True)
                        self.heatingVariableCost.setEnabled(True)
                        self.heatingFuelCost.setEnabled(True)
                        self.heatingFixedCost.setEnabled(True)
                        self.heatingElsale.setEnabled(True)
                        if t == z[0]:
                            self.sourceRead = self.simulator.sources_for_technology[9]  # 'Natural gas'
                        elif t == z[1]:
                            self.sourceRead = self.simulator.sources_for_technology[10]  # 'Heating Oil'
                        elif t == z[2]:
                            self.sourceRead = self.simulator.sources_for_technology[1]  # 'Biomass foresty'

                    if key == list(key_list)[4]:#solar_thermal
                        self.heatingEfficiency.setEnabled(True)
                        self.heatingInclinazione.setEnabled(True)
                        self.heating1coeff.setEnabled(True)
                        self.heating2coeff.setEnabled(True)
                        self.heatingTemp.setEnabled(True)
                        self.heatingVariableCost.setEnabled(True)
                        self.heatingFixedCost.setEnabled(True)
                        self.sourceRead = self.simulator.sources_for_technology[2]

                    if key ==list(key_list)[5]:#cooling_heat_pump
                        # self.heatingCapacity.lineEdit().setEnabled(True)
                        self.heatingVariableCost.lineEdit().setEnabled(True)

                        if t == z[0]:
                            self.sourceRead = self.simulator.sources_for_technology[
                                8]  # 'Geothermal - Shallow - Ground cold extraction'
                        elif t == z[1]:
                            self.sourceRead = self.simulator.sources_for_technology[5]  # 'Air'

                    # 7 thermal energy storage
                    # 8 domestic_hot_water_thermal_energy_storage
                    if key == list(key_list)[8] or key == list(key_list)[7]:
                        self.Tes_size_heating.setEnabled(True)
                        self.Soc_min_heating.setEnabled(True)
                        self.tes_startEnd_heating.setEnabled(True)
                        self.tes_discharge_heating.setEnabled(True)
                        self.heatingFixedCost.setEnabled(True)
                        self.heatingTES_loss.setEnabled(True)
                        self.heatingVariableCost.setEnabled(True)
                        self.sourceRead = self.simulator.sources_for_technology[0]

                    if key == list(key_list)[12]:  # absorption_heat_pump
                        self.P_max_heating.setEnabled(True)
                        self.COP_heating.setEnabled(True)
                        self.heatingVariableCost.setEnabled(True)
                        self.heatingFixedCost.setEnabled(True)
                        self.heatingFuelCost.setEnabled(True)
                        self.heatingTechMin.setEnabled(True)
                        self.heatingRampUpDown.setEnabled(True)
                        if t == z[0]:
                            self.sourceRead = self.simulator.sources_for_technology[5]  # 'Air'
                        if t == z[1]:
                            self.sourceRead = self.simulator.sources_for_technology[12]  # 'Geothermal - Shallow - Ground heat extraction'
                        if t == z[2]:  # "Absorption Heat Pump"
                            self.sourceRead = self.simulator.sources_for_technology[0]  # ' '
        return

    def disable_all_dhw_input(self):
        self.safe_disable_input(self.dhwElsale)
        self.safe_disable_input(self.dhwInclinazione)
        self.safe_disable_input(self.dhwTemp)
        self.safe_disable_input(self.dhwEfficiency)
        self.safe_disable_input(self.dhw1coeff)
        self.safe_disable_input(self.dhw2coeff)
        # self.safe_disable_input(self.dhwCapacity)
        self.safe_disable_input(self.dhwP_max)
        self.safe_disable_input(self.dhwP_min)
        self.safe_disable_input(self.dhwCb_CHP)
        self.safe_disable_input(self.dhwTechMin)
        self.safe_disable_input(self.dhwRampUpDown)
        self.safe_disable_input(self.dhwFixedCost)
        self.safe_disable_input(self.dhwFuelCost)
        self.safe_disable_input(self.dhwVariableCost)
        self.safe_disable_input(self.dhwTes_size)
        self.safe_disable_input(self.dhwSoc_min)
        self.safe_disable_input(self.dhwTes_startEnd)
        self.safe_disable_input(self.dhwTes_discharge)
        self.safe_disable_input(self.dhwCop)
        self.safe_disable_input(self.DHWTES_loss)

    def disable_all_heating_input(self):
        self.safe_disable_input(self.heatingElsale)
        self.safe_disable_input(self.heatingInclinazione)
        self.safe_disable_input(self.heatingTemp)
        self.safe_disable_input(self.heatingEfficiency)
        self.safe_disable_input(self.heating1coeff)
        self.safe_disable_input(self.heating2coeff)
        # self.safe_disable_input(self.heatingCapacity)
        self.safe_disable_input(self.P_max_heating)
        self.safe_disable_input(self.P_min_heating)
        self.safe_disable_input(self.cb_CHP_heating)
        self.safe_disable_input(self.heatingTechMin)
        self.safe_disable_input(self.heatingRampUpDown)
        self.safe_disable_input(self.heatingFixedCost)
        self.safe_disable_input(self.heatingFuelCost)
        self.safe_disable_input(self.heatingVariableCost)
        self.safe_disable_input(self.Tes_size_heating)
        self.safe_disable_input(self.Soc_min_heating)
        self.safe_disable_input(self.tes_startEnd_heating)
        self.safe_disable_input(self.tes_discharge_heating)
        self.safe_disable_input(self.COP_heating)
        self.safe_disable_input(self.heatingTES_loss)

    def disable_all_cooling(self):
        self.safe_disable_input(self.coolingInclinazione)
        self.safe_disable_input(self.coolingTemp)
        self.safe_disable_input(self.coolingEfficiency)
        self.safe_disable_input(self.cooling1coeff)
        self.safe_disable_input(self.cooling2coeff)
        self.safe_disable_input(self.P_max_cooling)
        self.safe_disable_input(self.P_min_cooling)
        self.safe_disable_input(self.cb_CHP_cooling)
        self.safe_disable_input(self.coolingTechMin)
        self.safe_disable_input(self.coolingRampUpDown)
        self.safe_disable_input(self.coolingFixedCost)
        self.safe_disable_input(self.coolingFuelCost)
        self.safe_disable_input(self.coolingVariableCost)
        self.safe_disable_input(self.Tes_size_cooling)
        self.safe_disable_input(self.cooling_socMin)
        self.safe_disable_input(self.cooling_tesStartEnd)
        self.safe_disable_input(self.tes_discharge_cooling)
        self.safe_disable_input(self.Cop_absorption_cooling)

    def disable_all_network_tech_input(self):
        self.safe_disable_input(self.networkarea)
        self.safe_disable_input(self.networkP_min)
        self.safe_disable_input(self.networkTemp)
        self.safe_disable_input(self.networkEta)
        self.safe_disable_input(self.network1coeff)
        self.safe_disable_input(self.network2coeff)
        self.safe_disable_input(self.networkP_max)
        self.safe_disable_input(self.networkP_min)
        self.safe_disable_input(self.networkcb_CHP)
        self.safe_disable_input(self.networkTechMin)
        self.safe_disable_input(self.networkRampUpDown)
        self.safe_disable_input(self.networkVariableCost)
        self.safe_disable_input(self.networkFixedCost)
        self.safe_disable_input(self.networkFuelCost)
        self.safe_disable_input(self.networkTes_size)
        self.safe_disable_input(self.networkSocMin)
        self.safe_disable_input(self.networkTesStartEnd)
        self.safe_disable_input(self.networkTes_discharge)
        self.safe_disable_input(self.networkCop_absorption)
        self.safe_disable_input(self.network_el_sale)
        self.safe_disable_input(self.networkTES_loss)

    def safe_disable_input(self, widget):
        try:
            widget.setEnabled(False)
        except Exception as e:
            print(e)

    def active_source_dialogDHW(self):
        self.sourceDhw = ' '
        self.disable_all_dhw_input()

        q = str(self.dhwTechnology.currentText())

        self.disable_all_dhw_input()

        key_list = self.simulator.individual_H_C_dict_var.keys()

        # loop over julia category
        for key in key_list:
            z = self.simulator.individual_H_C_dict_var[key]

            if q in z:
                if key == list(key_list)[0]:  # heat_only_boiler

                    self.dhwEfficiency.setEnabled(True)
                    # self.dhwCapacity.lineEdit().setEnabled(True)
                    self.dhwP_max.setEnabled(True)
                    self.dhwTechMin.setEnabled(True)
                    self.dhwRampUpDown.setEnabled(True)
                    self.dhwFixedCost.setEnabled(True)
                    self.dhwVariableCost.setEnabled(True)
                    self.dhwFuelCost.setEnabled(True)
                    if q == z[0]:
                        self.sourceDhw = self.simulator.sources_for_technology[9] # 'Natural gas'
                    if q == z[1]:
                        self.sourceDhw = self.simulator.sources_for_technology[1] # 'Biomass foresty'
                    if q == z[2]:
                        self.sourceDhw = self.simulator.sources_for_technology[10]  # 'Heating Oil'

                if key == list(key_list)[1]:  # electrical_heater
                    # self.dhwCapacity.lineEdit().setEnabled(True)
                    self.dhwEfficiency.setEnabled(True)
                    self.dhwVariableCost.setEnabled(True)
                    self.dhwFuelCost.setEnabled(True)
                    self.dhwFixedCost.setEnabled(True)
                    self.dhwTechMin.setEnabled(True)
                    self.dhwRampUpDown.setEnabled(True)
                    self.dhwP_max.setEnabled(True)
                    self.sourceDhw = self.simulator.sources_for_technology[11] # 'Electricity'

                if key == list(key_list)[2]:  # heat_pump
                    self.dhwP_max.setEnabled(True)
                    self.dhwTechMin.setEnabled(True)
                    self.dhwRampUpDown.setEnabled(True)
                    self.dhwVariableCost.setEnabled(True)
                    self.dhwTemp.setEnabled(True)
                    self.dhwFixedCost.setEnabled(True)
                    self.dhwFuelCost.setEnabled(True)
                    # self.simulator.ask_for_sources(q, serv="dhw")
                    if q == z[0]:
                        self.sourceDhw = self.simulator.sources_for_technology[5]
                    if q == z[1]:
                        self.sourceDhw = self.simulator.sources_for_technology[12]
                    if q == z[2]:
                        self.sourceDhw = self.simulator.ask_for_sources(t, serv="heating")

                    #self.sourceDhw = self.simulator.sources_for_technology[0]
                    #if q == z[1]:
                    #    self.sourceDhw = self.simulator.sources_for_technology[5] # 'Air'

                if key == list(key_list)[3]:  # cogeneration
                    self.dhwP_max.setEnabled(True)
                    self.dhwTechMin.setEnabled(True)
                    self.dhwEfficiency.setEnabled(True)
                    self.dhwRampUpDown.setEnabled(True)
                    self.dhwVariableCost.setEnabled(True)
                    self.dhwFuelCost.setEnabled(True)
                    self.dhwFixedCost.setEnabled(True)
                    self.dhwFixedCost.setEnabled(True)
                    self.dhwElsale.setEnabled(True)
                    self.dhwCb_CHP.setEnabled(True)
                    if q == z[0]:
                        self.sourceDhw = self.simulator.sources_for_technology[9] # 'Natural gas'
                    elif q == z[1]:
                        self.sourceDhw = self.simulator.sources_for_technology[10] # 'Heating Oil'
                    elif q == z[2]:
                        self.sourceDhw = self.simulator.sources_for_technology[1]  # 'Biomass foresty'

                if key == list(key_list)[4]:  # solar_thermal
                    self.dhwEfficiency.setEnabled(True)
                    self.dhwInclinazione.setEnabled(True)
                    self.dhw1coeff.setEnabled(True)
                    self.dhw2coeff.setEnabled(True)
                    self.dhwTemp.setEnabled(True)
                    self.dhwVariableCost.setEnabled(True)
                    self.dhwFixedCost.setEnabled(True)

                    self.sourceDhw = self.simulator.sources_for_technology[2] # ' '

                if key == list(key_list)[5]:  # cooling_heat_pump
                    # self.heatingCapacity.lineEdit().setEnabled(True)
                    self.heatingVariableCost.lineEdit().setEnabled(True)

                    if q == z[0]:
                        self.sourceDhw = self.simulator.sources_for_technology[8]  # 'Geothermal - Shallow - Ground cold extraction'
                    elif q == z[1]:
                        self.sourceDhw = self.simulator.sources_for_technology[5]  # 'Air'

                if key == list(key_list)[8] or key == list(key_list)[7]:  # 8 domestic_hot_water_thermal_energy_storage
                    self.dhwTes_size.setEnabled(True)
                    self.dhwSoc_min.setEnabled(True)
                    self.dhwTes_startEnd.setEnabled(True)
                    self.dhwTes_discharge.setEnabled(True)
                    self.dhwFixedCost.setEnabled(True)
                    self.DHWTES_loss.setEnabled(True)
                    self.dhwVariableCost.setEnabled(True)
                    self.sourceDhw = self.simulator.sources_for_technology[0] # ' '

                if key == list(key_list)[9] or key == list(key_list)[10] or key == list(key_list)[11]:
                    # 12-13-14 Waste Heat Compression Heat Pump Low T/Medium T/High T
                    self.dhwP_max.setEnabled(True)
                    self.dhwVariableCost.setEnabled(True)
                    self.dhwFuelCost.setEnabled(True)
                    self.dhwFixedCost.setEnabled(True)
                    self.dhwTechMin.setEnabled(True)

                if key == list(key_list)[12]:  # absorption_heat_pump
                    self.dhwP_max.setEnabled(True)
                    self.dhwCop.setEnabled(True)
                    self.dhwVariableCost.setEnabled(True)
                    self.dhwFuelCost.setEnabled(True)
                    self.dhwFixedCost.setEnabled(True)
                    self.dhwTechMin.setEnabled(True)
                    self.dhwRampUpDown.setEnabled(True)
                   # self.ask_for_sources(q)
                    if q == z[0]:
                        self.sourceDhw = self.simulator.sources_for_technology[5] # 'Air'
                    if q == z[1]:
                       self.sourceDhw = self.simulator.sources_for_technology[12] # 'Geothermal - Shallow - Ground heat extraction'
                    if q == z[2]:  # "Absorption Heat Pump"
                        self.sourceDhw = self.simulator.sources_for_technology[0]  # ' '
                #
                # if key == list(key_list)[9] or key == list(key_list)[10] or key == list(key_list)[11]:
                #     self.sourceDhw = self.list_sources_dhw[0]
                #     self.dhwP_max.lineEdit().setEnabled(True)
                #     self.dhwTechMin.lineEdit().setEnabled(True)
                #     self.dhwEfficiency.lineEdit().setEnabled(True)
                #     self.dhwRampUpDown.lineEdit().setEnabled(True)
                #     self.dhwVariableCost.lineEdit().setEnabled(True)
                #     self.dhwTemp.lineEdit().setEnabled(True)

                    # self.type_source_DHW.setEnabled(True)
                # else:
                    # self.type_source_DHW.setEnabled(False)

        return

    def active_source_dialogNetwork(self):
        self.disable_all_network_tech_input()

        self.sourceNet = ""

        t = str(self.networkTechnology.currentText())
        key_list = self.simulator.district_function.keys()

        print("step1_v2.py.active_source_dialogNetwork(). key_list:", key_list)

        for key in key_list:
            z = self.simulator.district_function[key]
            print("step1_v2.py.active_source_dialogNetwork(). Searching", t, "in list:", z)

            if t in z:
                if key == list(key_list)[0]:  # heat_only_boiler
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[0])
                    self.networkEta.setEnabled(True)
                    self.networkP_max.setEnabled(True)
                    self.networkTechMin.setEnabled(True)
                    self.networkRampUpDown.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    if t == z[0]:  # Gas Boiler
                        self.sourceNet = self.simulator.sources_for_technology[9]
                    if t == z[1]:  # Biomass Boiler
                        self.sourceNet = self.simulator.sources_for_technology[1]
                    if t == z[2]:  # Oil Boiler
                        self.sourceNet = self.simulator.sources_for_technology[10]
                    if t == z[3]:  # Boiler
                        self.sourceNet = self.simulator.sources_for_technology[0]
                    return

                if key == list(key_list)[1]:  # electrical_heater
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[1])
                    # self.networkCapacity.lineEdit().setEnabled(True)
                    self.networkEta.setEnabled(True)
                    self.networkP_max.setEnabled(True)
                    self.networkTechMin.setEnabled(True)
                    self.networkRampUpDown.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.sourceNet = self.simulator.sources_for_technology[11]
                    return

                if key == list(key_list)[2]:  # heat_pump
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[2])
                    self.networkP_max.setEnabled(True)
                    self.networkTechMin.setEnabled(True)
                    self.networkTemp.setEnabled(True)
                    self.networkRampUpDown.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    if t == z[0]:  # Air source compression heat pump
                        self.sourceNet = self.simulator.sources_for_technology[5]
                    if t == z[1]:  # Shallow geothermal compression heat pump
                        self.sourceNet = self.simulator.sources_for_technology[12]
                    if t == z[2]:  # Heat pump
                        self.sourceNet = self.simulator.sources_for_technology[0]
                    return
                else:
                    pass
                    # self.networkSources.setEnabled(False)

                if key == list(key_list)[3]:  # cogeneration
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[3])
                    self.networkP_max.setEnabled(True)
                    self.networkTechMin.setEnabled(True)
                    self.networkEta.setEnabled(True)
                    self.networkRampUpDown.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    self.network_el_sale.setEnabled(True)

                    if t == z[0]: # Gas CHP
                        self.sourceNet = self.simulator.sources_for_technology[9]
                    if t == z[1]: # Oil CHP
                        self.sourceNet = self.simulator.sources_for_technology[10]
                    if t == z[2]:
                        self.sourceNet = self.simulator.sources_for_technology[1]
                    if t == z[3]: # Cogeneration
                        self.sourceNet = self.simulator.sources_for_technology[0]
                    return

                if key == list(key_list)[4]:  # solar_thermal
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[4])
                    self.networkarea.setEnabled(True)
                    self.networkEta.setEnabled(True)
                    self.network1coeff.setEnabled(True)
                    self.network2coeff.setEnabled(True)
                    self.networkTemp.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.sourceNet = self.simulator.sources_for_technology[2]
                    return

                if key == list(key_list)[5]:  # 16 seasonal_solar_thermal
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[5])
                    self.networkTes_size.setEnabled(True)
                    self.networkSocMin.setEnabled(True)
                    self.networkTesStartEnd.setEnabled(True)
                    self.networkTes_discharge.setEnabled(True)
                    self.sourceNet = self.simulator.sources_for_technology[2]
                    return

                if key == list(key_list)[6]:  # absorption_heat_pump
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[6])
                    self.networkTechMin.setEnabled(True)
                    self.networkCop_absorption.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    self.networkP_max.setEnabled(True)
                    # self.networkSources.setEnabled(True)
                    # self.sourceNet = self.simulator.ask_tchnology_for_absoptionHeatPump(t)
                    if t == z[0]:  # Air source gas absorption heat pump
                        self.sourceNet = self.simulator.sources_for_technology[9]
                    if t == z[1]:  # Shallow geothermal gas absorption heat pump
                        self.sourceNet = self.simulator.sources_for_technology[12]
                    if t == z[2]:  # Absorption heat pump
                        self.sourceNet = self.simulator.sources_for_technology[0]
                    return

                if key == list(key_list)[7] or key == list(key_list)[8]:  # 7 waste_heat_heat_exchangers # 8 waste_cooling_heat_exchangers
                    # self.networkCapacity.lineEdit().setEnabled(True)
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[7])
                    #self.networkTechMin.setEnabled(True)
                    self.networkP_max.setEnabled(True)
                    self.networkP_min.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    if key == list(key_list)[8]:  # waste_cooling_heat_exchangers
                        self.simulator.ask_for_sources(t, serv="network")
                        self.sourceNet = self.simulator.selected_source
                    else:  # 7 waste_heat_heat_exchangers
                        if t == z[0]:  # Deep geothermal HEX
                            self.sourceNet = self.simulator.sources_for_technology[3]
                        if t == z[1]:  # Industrial waste heat HEX
                            self.sourceNet = self.simulator.sources_for_technology[14]
                        if t == z[2]:  # Waste heat – HEX
                            self.simulator.ask_for_sources(t, serv="network")
                            self.sourceNet = self.simulator.selected_source

                    return

                if key == list(key_list)[9] or key == list(key_list)[10] or key == list(key_list)[11]:  # waste_heat_heat_pumps_temperature_group1 ,2 ,3
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[9])
                    self.networkP_max.setEnabled(True)
                    self.networkTemp.setEnabled(True)
                    self.networkTechMin.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    self.simulator.ask_for_sources(t, serv="network")
                    self.sourceNet = self.simulator.selected_source
                    return

                if key == list(key_list)[13]:  # seasonal_waste_heat_pump
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[13])
                    # self.networkCapacity.lineEdit().setEnabled(True)
                    self.networkTechMin.setEnabled(True)
                    self.networkTemp.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.simulator.ask_for_sources(t, serv="network")
                    self.sourceNet = self.simulator.selected_source
                    # self.networkSources.setEnabled(True)
                    return
                else:
                    # self.networkSources.setEnabled(False)
                    pass


                # seasonal_solar_thermal energy storage
                # thermal energy storage
                if key == list(key_list)[14] or key == list(key_list)[12]:
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[14])
                    self.networkTes_size.setEnabled(True)
                    self.networkSocMin.setEnabled(True)
                    self.networkTesStartEnd.setEnabled(True)
                    self.networkTes_discharge.setEnabled(True)
                    self.networkTES_loss.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.sourceNet = self.simulator.sources_for_technology[2]
                    return

                if key == list(key_list)[15]:  # waste_heat_absorption_heat_pump
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[15])
                    self.networkTechMin.setEnabled(True)
                    self.networkCop_absorption.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    self.networkP_max.setEnabled(True)
                    self.simulator.ask_for_sources(t, serv="network")
                    self.sourceNet = self.simulator.selected_source
                    return

                if key == list(key_list)[16]:  # ORC Cogeneration
                    print("step1_v2.py.active_source_dialogNetwork(). Found", t, "in:", list(key_list)[16])
                    self.networkP_max.setEnabled(True)
                    self.networkTechMin.setEnabled(True)
                    self.networkEta.setEnabled(True)
                    self.networkRampUpDown.setEnabled(True)
                    self.networkVariableCost.setEnabled(True)
                    self.networkFixedCost.setEnabled(True)
                    self.networkFuelCost.setEnabled(True)
                    self.network_el_sale.setEnabled(True)
                    self.networkcb_CHP.setEnabled(True)
                    self.networkP_min.setEnabled(True)
                    if t == z[0]:  # Industrial waste heat ORC
                        self.sourceNet = self.simulator.sources_for_technology[14]
                    if t == z[1]:  # Deep geothermal ORC
                        self.sourceNet = self.simulator.sources_for_technology[3]
                    if t == z[2]:  # Gas ORC
                        self.sourceNet = self.simulator.sources_for_technology[9]
                    if t == z[3]:  # Biomass ORC
                        self.sourceNet = self.simulator.sources_for_technology[1]
                    return
        return

    def network_tree_widget_clicked(self, item, _):
        try:
            P_max = round(float(item.data(8, Qt.UserRole)), 2)
            self.networkP_max.setValue(P_max)
        except (ValueError, TypeError):
            return

    def insert_point(self):
        items_found = []
        for lista in [self.DHN_network_list, self.DCN_network_list]:
            for i in lista:
                supplies = i.get_supplies_names()
                if supplies is None:
                    continue
                if len(supplies) < 1:
                    continue
                for supply in supplies:
                    supply_name = supply[0] + " - " + i.name
                    for j in range(self.dmmTreeNetwork.topLevelItemCount()):
                        top_level_item = self.dmmTreeNetwork.topLevelItem(j)
                        if top_level_item.text(0) == supply_name and top_level_item.data(0, Qt.UserRole) == i.get_ID():
                            print("Step1_v2.py, insert_point(), supplie found!", top_level_item.text(0))
                            items_found.append(top_level_item)
                            break
                    else:
                        tree = QTreeWidgetItem()
                        tree.setText(0, supply_name)
                        tree.setData(0, Qt.UserRole, QVariant(str(i.get_ID())))
                        tree.setData(8, Qt.UserRole, QVariant(str(supply[1])))
                        self.dmmTreeNetwork.insertTopLevelItem(0, tree)
                        items_found.append(tree)
        # check if a generation point is not difference
        for j in range(self.dmmTreeNetwork.topLevelItemCount()):
            top_level_item = self.dmmTreeNetwork.topLevelItem(j)
            if top_level_item not in items_found:
                del top_level_item

    def locate_sources_DHN_old(self):
        for item in self.listWidget_4.selectedItems():
            network_index = self.listWidget_4.row(item)

            # If supply_layer is none, create it
            if self.DHN_network_list[network_index].supply_layer is None:
                # set generic crs here
                generate= self.DHN_network_list[network_index].name
                crs = self.building_layer.crs().authid()
                self.DHN_network_list[network_index].supply_layer = QgsVectorLayer("Point?crs=" + crs,
                                                                                   "generation_point" + " - " + generate,
                                                                                   "memory")
                # Show the layer
                group_name = "DHN" + " (" + self.DHN_network_list[network_index].scenario_type + "): " + self.DHN_network_list[network_index].name + " - ID:" + self.DHN_network_list[network_index].get_ID()
                add_layer_to_group(self.DHN_network_list[network_index].supply_layer, group_name)
                # Add fields :
                self.DHN_network_list[network_index].supply_layer.startEditing()
                self.DHN_network_list[network_index].supply_layer.dataProvider().addAttributes(
                    [QgsField("name", QVariant.String), QgsField("capacity_MW", QVariant.Double)])
                self.DHN_network_list[network_index].supply_layer.commitChanges()
            # Set update table when feature is added:
            self.DHN_network_list[network_index].supply_layer.featureAdded.connect(
                self.DHN_network_list[network_index].validate_sources)
            # Set active layer
            self.iface.setActiveLayer(self.DHN_network_list[network_index].supply_layer)
            # Start editing the layer
            if not self.DHN_network_list[network_index].supply_layer.isEditable():
                self.DHN_network_list[network_index].supply_layer.startEditing()
            # Start new point creation tool
            self.iface.actionAddFeature().trigger()
            # Enable validate and discard button
            # self.dock.clear_sources_button.setEnabled(True)
            # TODO : what if layer already exists ?

            for feature in self.DHN_network_list[network_index].supply_layer.getFeatures():
                geom = feature.geometry()
                print(self.DHN_network_list[network_index].supply_layer.name(), ": coordinates -", geom.asPoint().x(),
                      geom.asPoint().x())

    def locate_sources_DHN(self, dhcoptimizerplanheat):
        layer = dhcoptimizerplanheat.locate_sources('old_supply')
        for item in self.listWidget_4.selectedItems():
            network_index = self.listWidget_4.row(item)
            self.DHN_network_list[network_index].supply_layer = layer

        for feature in self.DHN_network_list[network_index].supply_layer.getFeatures():
            geom = feature.geometry()
            print(self.DHN_network_list[network_index].supply_layer.name(), ": coordinates -", geom.asPoint().x(),
                      geom.asPoint().x())

    def locate_sources_DCN_old(self):
        for item in self.listNetworkDCN.selectedItems():
            network_index = self.listNetworkDCN.row(item)

            # If supply_layer is none, create it
            if self.DCN_network_list[network_index].supply_layer is None:
                # set generic crs here
                crs = self.building_layer.crs().authid()
                self.DCN_network_list[network_index].supply_layer = QgsVectorLayer("Point?crs=" + crs,
                                                                                   "all_supply_%d" % self.study_id,
                                                                                   "memory")
                # Show the layer
                group_name = "DCN" + " (" + self.DCN_network_list[network_index].scenario_type + "): " + self.DCN_network_list[network_index].name + " - ID:" + self.DCN_network_list[network_index].get_ID()
                add_layer_to_group(self.DCN_network_list[network_index].supply_layer, group_name)
                # Add fields :
                self.DCN_network_list[network_index].supply_layer.startEditing()
                self.DCN_network_list[network_index].supply_layer.dataProvider().addAttributes(
                    [QgsField("name", QVariant.String), QgsField("capacity_MW", QVariant.Double)])
                self.DCN_network_list[network_index].supply_layer.commitChanges()
            # Set update table when feature is added:
            self.DCN_network_list[network_index].supply_layer.featureAdded.connect(
                self.DCN_network_list[network_index].validate_sources)
            # Set active layer
            self.iface.setActiveLayer(self.DCN_network_list[network_index].supply_layer)
            # Start editing the layer
            if not self.DCN_network_list[network_index].supply_layer.isEditable():
                self.DCN_network_list[network_index].supply_layer.startEditing()
            # Start new point creation tool
            self.iface.actionAddFeature().trigger()
            # Enable validate and discard button
            # self.dock.clear_sources_button.setEnabled(True)
            # TODO : what if layer already exists ?

            for feature in self.DCN_network_list[network_index].supply_layer.getFeatures():
                geom = feature.geometry()
                print(self.DCN_network_list[network_index].supply_layer.name(), ": coordinates -", geom.asPoint().x(),
                      geom.asPoint().x())

    def locate_sources_DCN(self, dhcoptimizerplanheat):
        layer = dhcoptimizerplanheat.locate_sources('old_supply')
        for item in self.listNetworkDCN.selectedItems():
            network_index = self.listNetworkDCN.row(item)
            self.DCN_network_list[network_index].supply_layer = layer

    def connect_building_toDHN(self):
        for i in self.DHN_network_list:
            i.connect_building_to_streets()
        self.refresh_DHN_network_streets()

    def connect_building_toDCN(self):
        for i in self.DCN_network_list:
            i.connect_building_to_streets()
        self.refresh_DCN_network_streets()

    def DCN_pipes_selected(self):
        self.pipes_selected(self.streetsListDCN, "DCN")

    def DHN_pipes_selected(self):
        self.pipes_selected(self.streetsListWidget, "DHN")

    def pipes_selected(self, widget, n_type):
        if len(widget.selectedItems()) < 1:
            return

        valid = False
        space = "                                       "
        while not valid:
            text, ok_pressed = QInputDialog.getText(self, "Specify pipe length", "Select the pipe diameter [cm]" + space, QLineEdit.Normal, "")
            try:
                pipe_diameter = float(text)
                valid = True
            except:
                pass

        for item in widget.selectedItems():
            row = item.text().split('|')
            try:
                pipe_id = int(row[0][9:-1])
            except:
                continue
            try:
                network_id = str(item.data(Qt.UserRole))
            except:
                continue
            if n_type == "DHN":
                for n in self.DHN_network_list:
                    if n.get_ID() == network_id:
                        for edg in n.graph.edges(data=True):
                            if edg[2]["feature_ID"] == pipe_id:
                                edg[2]["diameter"] = pipe_diameter
                                try:
                                    n.graph.edges[edg[1], edg[0], 0]["diameter"] = pipe_diameter
                                except:
                                    print("step1_v2.py, pipes_selected: problem with edge:", edg[1], edg[0], "id:",
                                          edg[2]["feature_ID"])
                                    pass
                                n.streets_layer.startEditing()
                                for ft in n.streets_layer.getFeatures():
                                    if int(ft.attribute(ft.fieldNameIndex('ID'))) == pipe_id:
                                        ft.setAttribute(ft.fieldNameIndex('diameter'), pipe_diameter)
                                        n.streets_layer.updateFeature(ft)
                                        break
                                n.streets_layer.commitChanges()
                                break
                        break
            if n_type == "DCN":
                for n in self.DCN_network_list:
                    if n.get_ID() == network_id:
                        for edg in n.graph.edges(data=True):
                            if edg[2]["feature_ID"] == pipe_id:
                                edg[2]["diameter"] = pipe_diameter
                                try:
                                    n.graph.edges[edg[1], edg[0], 0]["diameter"] = pipe_diameter
                                except:
                                    print("step1_v2.py, pipes_selected: problem with edge:", edg[1], edg[0], "id:",
                                          edg[2]["feature_ID"])
                                    pass
                                n.streets_layer.startEditing()
                                for ft in n.streets_layer.getFeatures():
                                    if int(ft.attribute(ft.fieldNameIndex('ID'))) == pipe_id:
                                        ft.setAttribute(ft.fieldNameIndex('diameter'), pipe_diameter)
                                        n.streets_layer.updateFeature(ft)
                                        break
                                n.streets_layer.commitChanges()
                                break
                        break
        if n_type == "DHN":
            self.refresh_DHN_network_streets()
        if n_type == "DCN":
            self.refresh_DCN_network_streets()


    def DHN_pipes_selection_changed(self):
        if self.pipes_selected_from_list:
            self.pipes_selected_from_list = False
            widget = self.streetsListWidget
            self.pipe_selection_changed(widget, "DHN")
            self.pipes_selected_from_list = True

    def DCN_pipes_selection_changed(self):
        if self.pipes_selected_from_list:
            self.pipes_selected_from_list = False
            widget = self.streetsListDCN
            self.pipe_selection_changed(widget, "DCN")
            self.pipes_selected_from_list = True

    def clear_selection(self, widget, n_type):
        n_list = []
        for item in widget.selectedItems():
            try:
                network_id = str(item.data(Qt.UserRole))
            except:
                continue
            if network_id not in n_list:
                n_list.append(network_id)
        if n_type == "DHN":
            for n in self.DHN_network_list:
                if n.get_ID() in n_list:
                    n.streets_layer.removeSelection()
        if n_type == "DCN":
            for n in self.DCN_network_list:
                if n.get_ID() in n_list:
                    n.streets_layer.removeSelection()

    def pipe_selection_changed(self, widget, n_type):
        self.clear_selection(widget, n_type)
        for item in widget.selectedItems():
            row = item.text().split('|')
            try:
                pipe_id = int(row[0][9:-1])
            except:
                continue
            try:
                network_id = str(item.data(Qt.UserRole))
            except:
                continue
            expr = QgsExpression("\"ID\"=" + str(pipe_id))
            if n_type == "DHN":
                for n in self.DHN_network_list:
                    if n.get_ID() == network_id:
                        ids = [ft.id() for ft in n.streets_layer.getFeatures(QgsFeatureRequest(expr))]
                        n.streets_layer.modifySelection(ids, [])
                        break
            if n_type == "DCN":
                for n in self.DCN_network_list:
                    if n.get_ID() == network_id:
                        ids = [ft.id() for ft in n.streets_layer.getFeatures(QgsFeatureRequest(expr))]
                        n.streets_layer.modifySelection(ids, [])
                        break

    # activated when a feature is selected in the QGIS interface.py
    def do_select_in_widget(self, n_type, n_id, id_list):
        if self.pipes_selected_from_list:
            self.pipes_selected_from_list = False
            if n_type == "DHN":
                widget = self.streetsListWidget
            if n_type == "DCN":
                widget = self.streetsListDCN
            for i in range(widget.count()):
                item = widget.item(i)
                row = item.text().split('|')
                try:
                    pipe_id = int(row[0][9:-1])
                except:
                    continue
                try:
                    network_id = str(item.data(Qt.UserRole))
                except:
                    continue
                if network_id == n_id:
                    if pipe_id in id_list:
                        item.setSelected(True)

                    else:
                        item.setSelected(False)

            self.pipes_selected_from_list = True

    def save_clicked(self):
        if self.check_sources() and self.check_tech_capacity():
            self.send_widget.emit(self.dmmTree, self.sourcesTable, self.DHN_network_list, self.DCN_network_list)
            if not self.networks_send:
                self.send_networks.emit([self.DHN_network_list, self.DCN_network_list], self.building_layer,
                                        self.street_layer, TechnologiesTransfer(self.dmmTree,
                                                                                n_tree=self.dmmTreeNetwork),
                                        SourceTransfer(self.sourcesTable))
                self.networks_send = True
                confirm_baseline: QPushButton = self.save
                confirm_baseline.setText("Go to step selection" if self.networks_send else "Confirm baseline scenario")
        else:
            print("step1, save_clicked: check_tech_capacity or check_sources failed")

    def check_tech_capacity(self):
        if self.muted:
            return True
        building_list = []
        for i in range(self.dmmTree.topLevelItemCount()):
            building = self.dmmTree.topLevelItem(i)
            for j in range(building.childCount()):
                tech_type = building.child(j)
                capacity = 0.0
                if tech_type.childCount() == 0:
                    continue
                for k in range(tech_type.childCount()):
                    technology = tech_type.child(k)
                    try:
                        capacity = capacity + float(technology.text(8))
                    except:
                        print("Step1, check_tech_capacity. Float conversion failed:", technology.text(8))
                if capacity < float(tech_type.text(1)):
                    building_list.append(building.text(0))
                    break

        if len(building_list) < 1:
            return True
        msgBox = QMessageBox()
        s = "\n"
        i = 0
        for building in building_list:
            s = s + "-> " + building + "\n"
            i = i + 1
            if i > 20:
                s = s + "-> " + "... other " + str(len(building_list) - 1) + " buildings..."
                break
        msgBox.setText("Are you sure to continue? The definition of the baseline scenario should be "
                       "completed before proceeding. Click Cancel and save your project if you're not sure")
        msgBox.setInformativeText("The technologies of the following buildings do not cover the peak demand: " + s)
        msgBox.setStandardButtons(QMessageBox.Cancel | QMessageBox.Ok)
        msgBox.setDefaultButton(QMessageBox.Cancel)
        ret = msgBox.exec()
        if ret == QMessageBox.Cancel:
            return False
        else:
            return True

    def val_demand(self, peak, peak_range, attribute_column_name):
        demand = []
        ids = []
        val_inf = peak - (peak_range / 2)
        val_sup = peak + (peak_range / 2)

        a = 0

        for f in self.building_layer.getFeatures():
            try:
                a = float(f.attribute(attribute_column_name))
            except:
                continue
            # demand.append(a)
            if a >= val_inf and a <= val_sup:
                ids.append(f.id())
        self.building_layer.modifySelection(ids, [])
        for i in range(self.dmmTree.topLevelItemCount()):
            item = self.dmmTree.topLevelItem(i)
            try:
                if int(item.text(0)) in ids:
                    item.setSelected(True)
            except:
                pass

    def insert_PeakDemandDhw(self):
        self.dialog.show()
        self.dialog.attribute_column_name = "MaxDHWDem"

    def insert_PeakDemandHeating(self):
        self.dialog.show()
        self.dialog.attribute_column_name = "MaxHeatDem"

    def insert_PeakDemandCooling(self):
        self.dialog.show()
        self.dialog.attribute_column_name = "MaxCoolDem"

    def allocate_sources_DHW(self):
        self.dialog_source.tech_source ="dhw"
        self.dialog_source.vis_interfaccia(self.dhwTechnology.currentText())
        self.dialog_source.show()

    def allocate_sources_heating(self):
        self.dialog_source.tech_source ="heating"
        self.dialog_source.vis_interfaccia(self.heatingTechnology.currentText())
        self.dialog_source.show()

    def allocate_source_cooling(self):
        self.dialog_source.tech_source = "cooling"
        self.dialog_source.show()

    def allocate_source_network(self):
        self.dialog_source.tech_source = "network"
        self.dialog_source.vis_interfaccia(self.networkTechnology.currentText())
        self.dialog_source.show()

    def recived_sources_selected(self):

        for i in range(self.dialog_source.model.rowCount()):
            item = self.dialog_source.model.item(i)

            if self.dialog_source.model.item(i).checkState()== QtCore.Qt.Checked:
                if self.dialog_source.tech_source == "dhw":
                    self.list_sources_dhw.append(item.text())
                if self.dialog_source.tech_source == "heating":
                    self.list_sources_heating.append(item.text())

                else:
                    self.list_sources_network.append(item.text())

        self.dialog_source.hide()

    def input_transportSector(self):

        consumption_gasoline =self.averegeGasoline.value()
        emissions_gasoline = self.averageCO2gasoline.value()
        gasoline_calorific = self.gasoline.value()
        consumption_diesel = self.averageDiesel.value()
        diesel_calorific = self.diesel.value()
        emissions_diesel = self.averageCO2diesel.value()
        nr_ofPerson = self.personalVehicles.value()
        gasoline_vehicle = self.gasolineVehicles.value()
        daily_distance = self.dailyDistance.value()
        nr_electricalVeicle = self.electricVehicles.value()
        specific_energy = self.energyConsum.value()
        electrical_sector = self.co2ElectricalSector.value()
        battery_capacity = self.avarageBattery.value()
        charging_discharging = self.avarageChargingDischarging.value()
        diesel_vehicles = self.dieselVehicles.value()
        weekend = self.weekend.value()
        winter = self.btnWinter.value()
        spring = self.btnSpring.value()
        summer = self.btnSummer.value()
        autumn = self.btnAutumn.value()

        self.list_input =[
                 consumption_gasoline,
                 emissions_gasoline,
                 gasoline_calorific,
                 consumption_diesel,
                 diesel_calorific,
                 emissions_diesel,
                 nr_ofPerson,
                 gasoline_vehicle,
                 daily_distance,
                 nr_electricalVeicle,
                 nr_electricalVeicle,
                 specific_energy,
                 electrical_sector,
                 battery_capacity,
                 charging_discharging,
                 diesel_vehicles, weekend, winter,
                 spring,
                 summer,
                 autumn]



        # self.trasport_sector_calc.cacluation_transport(self.list_input)

    def check_sources(self):
        if self.muted:
            return True
        check_result = {}
        for i in range(self.step0_table.rowCount()):
            try:
                source = self.step0_table.item(i, 0).text()
            except:
                source = ""
            try:
                availability = float(self.step0_table.item(i, 1).text())
                availability = round(availability, 2)
            except:
                availability = 0
            if not source == "":
                used = self.sum_sources_used(source)
                if availability < used:
                    check_result[source] = [availability, used]
        if len(check_result) == 0:
            message = ""
        else:
            message = "Source availability: " + str(len(check_result)) + " warnings!\n\n"
        for key in check_result.keys():
            message = message + "- " + str(key) + " available: " + str(check_result[key][0]) + "MW, used: " + str(check_result[key][1]) + "MW\n"

        msgBox = QMessageBox()
        msgBox.setText("Are you sure to continue?")
        msgBox.setInformativeText(message)
        msgBox.setStandardButtons(QMessageBox.Cancel | QMessageBox.Ok)
        msgBox.setDefaultButton(QMessageBox.Cancel)
        ret = msgBox.exec()

        if ret == QMessageBox.Cancel:
            return False
        else:
            return True

    def sum_sources_used(self, source):
        output = 0
        for i in range(self.dmmTree.topLevelItemCount()):
            building = self.dmmTree.topLevelItem(i)
            for j in range(building.childCount()):
                H_C_DHW_DHWH = building.child(j)
                for k in range(H_C_DHW_DHWH.childCount()):
                    technology = H_C_DHW_DHWH.child(k)
                    if technology.text(2) == source:
                        try:
                            output = output + float(technology.text(8))/1000.0  #1000.0 if step0 tab is in MW
                        except:
                            pass
        for i in range(self.dmmTreeNetwork.topLevelItemCount()):
            network = self.dmmTreeNetwork.topLevelItem(i)
            for j in range(network.childCount()):
                gen_point = network.child(j)
                if gen_point.text(2) == source:
                    try:
                        output = output + float(technology.text(8))
                    except:
                        pass
        try:
            output = round(output, 2)
        except:
            pass
        return output

    def remove_tech(self, service):
        CustomContextMenu.erode_method(CustomContextMenu.get_top_level(self.dmmTree.currentItem()), service=service)
        # children = []
        # for child in range(selected.childCount()):
        #     # for t in range(selected.child(child).childCount()):
        #     # if (selected.child(child).child(t) != None):
        #     children.append(selected.child(child))
        # for child in children:
        #     selected.removeChild(child)

    def remove_technology(self):
        selected = self.dmmTreeNetwork.currentItem()
        if selected.parent() is not None:
            selected.parent().removeChild(selected)
        else:
            for i in range(selected.childCount()-1, -1, -1):
                selected.removeChild(selected.child(i))

    def load_folder_dhn(self):
        folder_DHN = str(QFileDialog.getExistingDirectory(self, "Select Directory"))
        self.folder_DHN.setText(folder_DHN)

    def load_folder_dcn(self):
        folder_DCN = str(QFileDialog.getExistingDirectory(self, "Select Directory"))
        self.folder_DCN.setText(folder_DCN)


    def upload_file(self):
        upload = Upload()
        upload.upload_file_json()

    def tab_current_changed(self, index):
        if index == 2:
            self.insert_point()

    def DHN_optimization(self):
        # for n in self.futureDHN_network_list:
        #     self.optimize_network(n)
        self.add_old_buildings_button_2.setEnabled(False)
        self.add_old_streets_button_2.setEnabled(False)
        self.generate_existing_network_button_2.setEnabled(False)
        self.closeEditing_2.setEnabled(False)
        self.listWidget_4.itemSelectionChanged.disconnect()
        self.add_existing_network_button_2.setEnabled(False)

        self.add_old_buildings_button.setEnabled(True)
        self.add_old_streets_button.setEnabled(True)
        self.generate_existing_network_button.setEnabled(True)
        self.closeEditing.setEnabled(True)
        self.listNetworkDCN.itemSelectionChanged.disconnect()
        self.add_existing_network_button.setEnabled(False)

        self.pipesDiameter.setEnabled(True)
        self.setDiameter.setEnabled(True)
        self.pipesDiameter_2.setEnabled(False)
        self.setDiameter_2.setEnabled(False)
        self.connect_generation_point_2.setEnabled(False)
        self.connect_generation_point.setEnabled(True)
        self.create_generation_point_2.setEnabled(False)
        self.create_generation_point.setEnabled(True)

        self.listWidget_4.setEnabled(False)
        self.addNetwork.setEnabled(False)
        self.pushButton_4.setEnabled(False)
        self.listNetworkDCN.setEnabled(False)
        self.addDCN.setEnabled(False)
        self.removeDCN.setEnabled(False)

        for i in [0, 3, 4]:
            self.phases.setTabEnabled(i, False)
        self.tabWidget.setTabEnabled(2, False)

        self.generate_graph_done = False
        self.create_generation_point.setEnabled(False)
        self.connect_generation_point.setEnabled(False)
        widget = self.listWidget_4
        self.hide_layers_before_editing_networks("DHN", widget.selectedItems())
        self.router_optimizer(widget)

    def DCN_optimization(self):
        # for n in self.futureDCN_network_list:
        #     self.optimize_network(n)
        self.add_old_buildings_button.setEnabled(False)
        self.add_old_streets_button.setEnabled(False)
        self.generate_existing_network_button.setEnabled(False)
        self.closeEditing.setEnabled(False)
        self.listWidget_4.itemSelectionChanged.disconnect()
        self.add_existing_network_button.setEnabled(False)

        self.add_old_buildings_button_2.setEnabled(True)
        self.add_old_streets_button_2.setEnabled(True)
        self.generate_existing_network_button_2.setEnabled(True)
        self.closeEditing_2.setEnabled(True)
        self.listNetworkDCN.itemSelectionChanged.disconnect()
        self.add_existing_network_button_2.setEnabled(False)

        self.pipesDiameter.setEnabled(False)
        self.setDiameter.setEnabled(False)
        self.pipesDiameter_2.setEnabled(True)
        self.setDiameter_2.setEnabled(True)
        self.connect_generation_point_2.setEnabled(True)
        self.connect_generation_point.setEnabled(False)
        self.create_generation_point_2.setEnabled(True)
        self.create_generation_point.setEnabled(False)

        self.listWidget_4.setEnabled(False)
        self.addNetwork.setEnabled(False)
        self.pushButton_4.setEnabled(False)
        self.listNetworkDCN.setEnabled(False)
        self.addDCN.setEnabled(False)
        self.removeDCN.setEnabled(False)

        for i in [0, 3, 4]:
            self.phases.setTabEnabled(i, False)
        self.tabWidget.setTabEnabled(2, False)

        self.generate_graph_done = False
        self.create_generation_point_2.setEnabled(False)
        self.connect_generation_point_2.setEnabled(False)
        widget = self.listNetworkDCN
        self.hide_layers_before_editing_networks("DCN", widget.selectedItems())
        self.router_optimizer(widget)

    def reset_network_buttons(self):
        self.add_old_buildings_button.setEnabled(False)
        self.add_old_streets_button.setEnabled(False)
        self.generate_existing_network_button.setEnabled(False)
        self.closeEditing.setEnabled(False)
        self.save_existing_network_button.setEnabled(False)
        self.listWidget_4.itemSelectionChanged.connect(lambda: self.update_editing_available("DHN"))

        self.add_old_buildings_button_2.setEnabled(False)
        self.add_old_streets_button_2.setEnabled(False)
        self.generate_existing_network_button_2.setEnabled(False)
        self.closeEditing_2.setEnabled(False)
        self.save_existing_network_button_2.setEnabled(False)
        self.listNetworkDCN.itemSelectionChanged.connect(lambda: self.update_editing_available("DCN"))

        self.pipesDiameter.setEnabled(False)
        self.setDiameter.setEnabled(False)
        self.pipesDiameter_2.setEnabled(False)
        self.setDiameter_2.setEnabled(False)
        self.connect_generation_point.setEnabled(False)
        self.connect_generation_point_2.setEnabled(False)
        self.create_generation_point.setEnabled(False)
        self.create_generation_point_2.setEnabled(False)

        self.listWidget_4.setEnabled(True)
        self.addNetwork.setEnabled(True)
        self.pushButton_4.setEnabled(True)
        self.listNetworkDCN.setEnabled(True)
        self.addDCN.setEnabled(True)
        self.removeDCN.setEnabled(True)

        for i in [0, 3, 4]:
            self.phases.setTabEnabled(i, True)
        self.tabWidget.setTabEnabled(2, True)

    def router_optimizer(self, widget):
        if len(widget.selectedItems()) > 1:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Warning)
            msgBox.setText("Too many networks selected")
            msgBox.setInformativeText("Please, select a single network before running the Router Optimizer.")
            msgBox.setStandardButtons(QMessageBox.Ok)
            msgBox.setDefaultButton(QMessageBox.Ok)
            ret = msgBox.exec()
            self.reset_network_buttons()
            return
        if len(widget.selectedItems()) < 1:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Warning)
            msgBox.setText("No network selected.")
            msgBox.setInformativeText("Please, select a network before running the Router Optimizer.")
            msgBox.setStandardButtons(QMessageBox.Ok)
            msgBox.setDefaultButton(QMessageBox.Ok)
            ret = msgBox.exec()
            self.reset_network_buttons()
            return
        network_index = widget.row(widget.selectedItems()[0])
        if widget == self.listWidget_4:
            network = self.DHN_network_list[network_index]
        else:
            network = self.DCN_network_list[network_index]
        root = QgsProject.instance().layerTreeRoot()
        network_node = root.findGroup(network.get_group_name())
        if network_node is None:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Critical)
            msgBox.setText("Critical error.")
            msgBox.setInformativeText("Network node not found. Expecting group " + network.get_group_name())
            msgBox.setStandardButtons(QMessageBox.Ok)
            msgBox.setDefaultButton(QMessageBox.Ok)
            ret = msgBox.exec()
            self.reset_network_buttons()
            return
        else:
            result_node = network_node.findGroup("Router Optimizer RESULTS")
            if result_node is not None:
                msgBox = QMessageBox()
                msgBox.setIcon(QMessageBox.Warning)
                msgBox.setText("Router Optimizer already executed.")
                msgBox.setInformativeText(
                    "To execute another instance of the Router Optimizer for network " + network.name + " old result data will be replaced with the saved one. Pressing Ok is safe.")
                msgBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
                msgBox.setDefaultButton(QMessageBox.Cancel)
                ret = msgBox.exec()
                if ret == QMessageBox.Ok:
                    network_node.removeChildNode(result_node)
                else:
                    self.reset_network_buttons()
                    return
        if network.scenario_type == "baseline":
            scenario_type = "Baseline"
        else:
            scenario_type = "Future"

        if self.work_folder is not None:
            folder = os.path.join(self.work_folder, scenario_type, "Networks", network.n_type, network.get_ID())
        else:
            folder = os.path.join(os.path.dirname(os.path.realpath(__file__)), "save_utility", "DefaultSaveFolder",
                                  scenario_type, "Networks", network.n_type, network.get_ID())
        if not os.path.exists(folder):
            os.makedirs(folder, exist_ok=True)
            self.data_transfer.automatic_upload_network = False
        elif os.path.isfile(os.path.join(folder, network.name + ".zip")):
            self.data_transfer.automatic_upload_network = True
        else:
            self.data_transfer.automatic_upload_network = False
        network.save_file_path = os.path.join(folder, network.name + ".zip")

        self.data_transfer.network = network
        self.data_transfer.study_id += 1
        self.data_transfer.step1_mode = True

        try:
            self.setDiameter.clicked.disconnect()
        except TypeError:
            pass
        self.data_transfer.pipes_list = PipeList()
        if self.data_transfer.pipes_list.layer is not None:
            print("step1_v2.py, router_optimizer(), self.data_transfer.pipes_list.layer.name():", self.data_transfer.pipes_list.layer.name())
        else:
            print("step1_v2.py, router_optimizer(), self.data_transfer.pipes_list.layer.name():",
                  "is NONE")
        if network.n_type == "DHN":
            self.data_transfer.pipes_list.widget = self.pipesDiameter
        else:
            self.data_transfer.pipes_list.widget = self.pipesDiameter_2

        self.setDiameter.clicked.connect(self.data_transfer.pipes_list.set_pipes_diameter)
        self.setDiameter_2.clicked.connect(self.data_transfer.pipes_list.set_pipes_diameter)

        dhcoptimizerplanheat = DHCOptimizerPlanheat(self.iface, 
                                                    working_directory=folder, 
                                                    data_transfer=self.data_transfer)
        dhcoptimizerplanheat.dialog_menu.radioButton_1_auto.setEnabled(False)
        dhcoptimizerplanheat.dialog_menu.radioButton_1_auto.setChecked(True)
        dhcoptimizerplanheat.dialog_menu.radioButton_2_manual.setChecked(False)

        self.add_old_buildings_button.clicked.connect(lambda: self.add_buildings(dhcoptimizerplanheat))
        self.add_old_streets_button.clicked.connect(lambda: self.add_streets_optimizer(dhcoptimizerplanheat))
        self.generate_existing_network_button.clicked.connect(lambda: self.generate_geography(dhcoptimizerplanheat, "DHN"))
        self.closeEditing.clicked.connect(lambda: self.close_optimizer(dhcoptimizerplanheat))
        self.add_old_buildings_button_2.clicked.connect(lambda: self.add_buildings(dhcoptimizerplanheat))
        self.add_old_streets_button_2.clicked.connect(lambda: self.add_streets_optimizer(dhcoptimizerplanheat))
        self.generate_existing_network_button_2.clicked.connect(lambda: self.generate_geography(dhcoptimizerplanheat, "DCN"))
        self.closeEditing_2.clicked.connect(lambda: self.close_optimizer(dhcoptimizerplanheat))
        self.create_generation_point.clicked.connect(lambda: self.locate_sources_DHN(dhcoptimizerplanheat))
        self.create_generation_point_2.clicked.connect(lambda: self.locate_sources_DCN(dhcoptimizerplanheat))
        self.connect_generation_point.clicked.connect(lambda: dhcoptimizerplanheat.connect_sources())
        self.connect_generation_point_2.clicked.connect(lambda: dhcoptimizerplanheat.connect_sources())

        dhcoptimizerplanheat.dock.closed.connect(lambda: self.dhcoptimizerplanheat_closed(dhcoptimizerplanheat))
        dhcoptimizerplanheat.manual_dock.closed.connect(lambda: self.dhcoptimizerplanheat_closed(dhcoptimizerplanheat))
        # dhcoptimizerplanheat.dialog_menu.closed.connect(lambda: self.dhcoptimizerplanheat_closed(dhcoptimizerplanheat,
        #                                                                                          dialog_dock=self.dialog_dock))
        #
        dhcoptimizerplanheat.run()

        canvas = self.iface.mapCanvas()
        root = QgsProject.instance().layerTreeRoot()
        for layer in root.findLayers():
            if layer.name().startswith("all_streets_{0}".format(self.data_transfer.study_id)):
                proj = QgsProject.instance()
                ex = layer.layer().extent()

                if layer.layer().crs().authid() != proj.crs().authid():
                    print("Layer has not the same CRS as proj", 
                          layer.layer().crs().authid(), proj.crs().authid())
                    tr = QgsCoordinateTransform(layer.layer().crs(), proj.crs(), proj)
                    ex = tr.transform(ex)
                canvas.setExtent(ex)
                canvas.refresh()

        # if self.dialog_dock:
        #     self.hide()
        # self.dialog_dock = True

    def close_optimizer(self, dhcoptimizerplanheat):
        if not self.generate_graph_done:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Warning)
            msgBox.setText("No geography found.")
            msgBox.setInformativeText("Please, use the Generate geography functionality first.")
            msgBox.setStandardButtons(QMessageBox.Ok)
            msgBox.setDefaultButton(QMessageBox.Ok)
            ret = msgBox.exec()
        else:
            dhcoptimizerplanheat.dock.closed.emit()
            del dhcoptimizerplanheat
            self.data_transfer.pipes_list.clear_list()
            self.data_transfer.network.optimizer_results = self.data_transfer.get_results()
            print(self.data_transfer.network.optimizer_results)

            self.reset_network_buttons()

    def dhcoptimizerplanheat_closed(self, dhcoptimizerplanheat, dialog_dock=False):

        dhcoptimizerplanheat.dock.save_existing_network_button.clicked.emit()
        root = QgsProject.instance().layerTreeRoot()
        network_group_name = dhcoptimizerplanheat.data_transfer.network.get_group_name()
        network_node = root.findGroup(network_group_name)
        if network_node is None:
            print("Step4_dockwidget.py, dhcoptimizerplanheat_closed(). ERROR: network node not found")
        old = dhcoptimizerplanheat.data_transfer.tree_group
        try:
            new = old.clone()
        except RuntimeError:
            root = QgsProject.instance().layerTreeRoot()
            old = root.findGroup(dhcoptimizerplanheat.data_transfer.tree_group_name)
            new = old.clone()
        network_node.addChildNode(new)
        network_node.removeChildNode(old)
        new.setName("Router Optimizer RESULTS")

        self.network_optimizer_post_processing(dhcoptimizerplanheat.data_transfer)

        self.add_old_buildings_button.clicked.disconnect()
        self.add_old_streets_button.clicked.disconnect()
        self.generate_existing_network_button.clicked.disconnect()
        self.closeEditing.clicked.disconnect()
        self.add_old_buildings_button_2.clicked.disconnect()
        self.add_old_streets_button_2.clicked.disconnect()
        self.generate_existing_network_button_2.clicked.disconnect()
        self.closeEditing_2.clicked.disconnect()
        dhcoptimizerplanheat.dock.closed.disconnect()
        dhcoptimizerplanheat.manual_dock.closed.disconnect()
        self.setDiameter.clicked.disconnect()
        self.setDiameter_2.clicked.disconnect()
        self.create_generation_point.clicked.disconnect()
        self.create_generation_point_2.clicked.disconnect()
        self.connect_generation_point.clicked.disconnect()
        self.connect_generation_point_2.clicked.disconnect()
        # self.show()

    def network_optimizer_post_processing(self, data_transfer):
        data_transfer.network.optimized = True
        self.insert_point()
        data_transfer.step1_mode = False
        self.tree_item_manager.update_buildings_visualizzation()

    def get_data_transfer(self, _, data_transfer):
        self.data_transfer = data_transfer

    def connect_generation_point_DHN(self):
        widget = self.listWidget_4
        self.connect_generation_points_to_network(widget)

    def connect_generation_point_DCN(self):
        widget = self.listNetworkDCN
        self.connect_generation_points_to_network(widget)

    def connect_generation_points_to_network(self, widget):
        supply_layer = None
        streets_layer = None
        root = QgsProject.instance().layerTreeRoot()
        network_group_name = self.data_transfer.network.get_group_name()
        network_node = root.findGroup(network_group_name)
        if network_node is None:
            print("Step1_V2.py, connect_generation_points_to_network(). ERROR: network node not found")
            return
        for l in network_node.findLayers():
            if l.layer().name() == "generation_point - " + self.data_transfer.network.name:
                supply_layer = l.layer()
            if l.layer().name()[0:18] == "old_network_edges_":
                streets_layer = l.layer()
        if streets_layer is None:
            msgBox = QMessageBox()
            msgBox.setIcon(QMessageBox.Warning)
            msgBox.setText("No geography found.")
            msgBox.setInformativeText("Please, use the Generate geography functionality first.")
            msgBox.setStandardButtons(QMessageBox.Ok)
            msgBox.setDefaultButton(QMessageBox.Ok)
            ret = msgBox.exec()
            return
        if supply_layer is None:
            print("Step1_V2.py, connect_generation_points_to_network(). ERROR: supply_layer is None")
            return
        self.data_transfer.network.connect_generation_points_v2(supply_layer, streets_layer)

    def hide_layers_before_editing_networks(self, mode, network_name):
        # hide original street layer (will be recreated)
        # hide future and baseline building shape (not usefull)
        ui_utils.hide_layers(["all_streets_0", "future_scenario", "baseline_scenario"])

        # hide other studies
        if len(network_name) > 0:
            network_name = network_name[0].text()
            root = QgsProject.instance().layerTreeRoot()
            for child in root.children():
                print(child.name())
                if child.name().startswith("{0} (baseline)".format(mode)) \
                and network_name not in child.name():
                    child.setItemVisibilityChecked(False)
                    child.setExpanded(False)

    def update_editing_available(self, mode):
        if mode == "DHN":
            self.add_existing_network_button.setEnabled(len(list(self.listWidget_4.selectedItems())) == 1)
        if mode == "DCN":
            self.add_existing_network_button_2.setEnabled(len(list(self.listNetworkDCN.selectedItems())) == 1)

    def additional_parameters_btn_handler(self):
        self.dialog_additional_parameters = AdditionalSimulationParameterGUI(data=self.KPIs_additional_data,
                                                                             description="Baseline Scenario additional parameters:")
        self.dialog_additional_parameters.data_emitter.connect(self.receive_additional_parameters)
        self.dialog_additional_parameters.show()

    def receive_additional_parameters(self, data):
        if isinstance(data, dict):
            self.KPIs_additional_data = data

    def update_building_tree_state(self):
        for i in range(self.dmmTree.topLevelItemCount()):
            item = self.dmmTree.topLevelItem(i)
            try:
                building_feature_id = int(item.text(0))
                for networks in [self.DHN_network_list, self.DCN_network_list]:
                    for network in networks:
                        pass
            except Exception:
                pass


